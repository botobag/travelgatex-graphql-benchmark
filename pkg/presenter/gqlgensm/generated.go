// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlgensm

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"github.com/travelgateX/presenters-benchmark/pkg/access"
	"github.com/travelgateX/presenters-benchmark/pkg/common"
	"github.com/travelgateX/presenters-benchmark/pkg/domainHotelCommon"
	"github.com/travelgateX/presenters-benchmark/pkg/search"
	"strconv"
	"sync"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/vektah/gqlparser"
	"github.com/vektah/gqlparser/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	HotelOptionSearch() HotelOptionSearchResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AddOn struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	AddOns struct {
		Distribute   func(childComplexity int) int
		Distribution func(childComplexity int) int
	}

	AuditData struct {
		Transactions func(childComplexity int) int
		TimeStamp    func(childComplexity int) int
		ProcessTime  func(childComplexity int) int
	}

	Bed struct {
		Type        func(childComplexity int) int
		Description func(childComplexity int) int
		Count       func(childComplexity int) int
		Shared      func(childComplexity int) int
	}

	CancelPenalty struct {
		HoursBefore func(childComplexity int) int
		PenaltyType func(childComplexity int) int
		Currency    func(childComplexity int) int
		Value       func(childComplexity int) int
	}

	CancelPolicy struct {
		Refundable      func(childComplexity int) int
		CancelPenalties func(childComplexity int) int
	}

	CriteriaSearch struct {
		CheckIn     func(childComplexity int) int
		CheckOut    func(childComplexity int) int
		Hotels      func(childComplexity int) int
		Occupancies func(childComplexity int) int
		Language    func(childComplexity int) int
		Currency    func(childComplexity int) int
		Nationality func(childComplexity int) int
		Market      func(childComplexity int) int
	}

	Error struct {
		Code        func(childComplexity int) int
		Type        func(childComplexity int) int
		Description func(childComplexity int) int
	}

	Exchange struct {
		Currency func(childComplexity int) int
		Rate     func(childComplexity int) int
	}

	HotelOptionSearch struct {
		SupplierCode      func(childComplexity int) int
		AccessCode        func(childComplexity int) int
		Market            func(childComplexity int) int
		HotelCode         func(childComplexity int) int
		HotelCodeSupplier func(childComplexity int) int
		HotelName         func(childComplexity int) int
		BoardCode         func(childComplexity int) int
		BoardCodeSupplier func(childComplexity int) int
		PaymentType       func(childComplexity int) int
		Status            func(childComplexity int) int
		Occupancies       func(childComplexity int) int
		Rooms             func(childComplexity int) int
		Price             func(childComplexity int) int
		Supplements       func(childComplexity int) int
		Surcharges        func(childComplexity int) int
		RateRules         func(childComplexity int) int
		CancelPolicy      func(childComplexity int) int
		Remarks           func(childComplexity int) int
		AddOns            func(childComplexity int) int
		Token             func(childComplexity int) int
		Id                func(childComplexity int) int
	}

	HotelSearch struct {
		Context         func(childComplexity int) int
		Stats           func(childComplexity int, token string) int
		AuditData       func(childComplexity int) int
		RequestCriteria func(childComplexity int) int
		Options         func(childComplexity int) int
		Errors          func(childComplexity int) int
		Warnings        func(childComplexity int) int
	}

	HotelXquery struct {
		Search              func(childComplexity int) int
		SearchStatusService func(childComplexity int) int
	}

	Markup struct {
		Channel  func(childComplexity int) int
		Currency func(childComplexity int) int
		Binding  func(childComplexity int) int
		Net      func(childComplexity int) int
		Gross    func(childComplexity int) int
		Exchange func(childComplexity int) int
		Rules    func(childComplexity int) int
	}

	Occupancy struct {
		Id    func(childComplexity int) int
		Paxes func(childComplexity int) int
	}

	Pax struct {
		Age func(childComplexity int) int
	}

	Price struct {
		Currency func(childComplexity int) int
		Binding  func(childComplexity int) int
		Net      func(childComplexity int) int
		Gross    func(childComplexity int) int
		Exchange func(childComplexity int) int
		Markups  func(childComplexity int) int
	}

	PriceBreakdown struct {
		EffectiveDate func(childComplexity int) int
		ExpireDate    func(childComplexity int) int
		Price         func(childComplexity int) int
	}

	Promotion struct {
		Code          func(childComplexity int) int
		Name          func(childComplexity int) int
		EffectiveDate func(childComplexity int) int
		ExpireDate    func(childComplexity int) int
	}

	Query struct {
		HotelX func(childComplexity int) int
	}

	RatePlan struct {
		Code          func(childComplexity int) int
		Name          func(childComplexity int) int
		EffectiveDate func(childComplexity int) int
		ExpireDate    func(childComplexity int) int
	}

	Resort struct {
		Code        func(childComplexity int) int
		Name        func(childComplexity int) int
		Description func(childComplexity int) int
	}

	Room struct {
		OccupancyRefId func(childComplexity int) int
		Code           func(childComplexity int) int
		Description    func(childComplexity int) int
		Refundable     func(childComplexity int) int
		Units          func(childComplexity int) int
		RoomPrice      func(childComplexity int) int
		Beds           func(childComplexity int) int
		RatePlans      func(childComplexity int) int
		Promotions     func(childComplexity int) int
	}

	RoomCriteria struct {
		Paxes func(childComplexity int) int
	}

	RoomPrice struct {
		Price     func(childComplexity int) int
		Breakdown func(childComplexity int) int
	}

	Rule struct {
		Id    func(childComplexity int) int
		Name  func(childComplexity int) int
		Type  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	Search struct {
		Hotel func(childComplexity int, token *string, criteria *HotelCriteriaSearchInput, settings *domainHotelCommon.Settings, filter *search.Filter) int
	}

	ServiceStatus struct {
		Code        func(childComplexity int) int
		Type        func(childComplexity int) int
		Description func(childComplexity int) int
	}

	Stat struct {
		Start    func(childComplexity int) int
		End      func(childComplexity int) int
		Duration func(childComplexity int) int
	}

	StatAccess struct {
		Name                func(childComplexity int) int
		Total               func(childComplexity int) int
		StaticConfiguration func(childComplexity int) int
		Hotels              func(childComplexity int) int
		Zones               func(childComplexity int) int
		Cities              func(childComplexity int) int
		RequestAccess       func(childComplexity int) int
		ResponseAccess      func(childComplexity int) int
		Transactions        func(childComplexity int) int
		Plugins             func(childComplexity int) int
	}

	StatPlugin struct {
		Name  func(childComplexity int) int
		Total func(childComplexity int) int
	}

	StatTransaction struct {
		Reference           func(childComplexity int) int
		Total               func(childComplexity int) int
		BuildRequest        func(childComplexity int) int
		WorkerCommunication func(childComplexity int) int
		ParseResponse       func(childComplexity int) int
	}

	StatsRequest struct {
		Total          func(childComplexity int) int
		Validation     func(childComplexity int) int
		Process        func(childComplexity int) int
		Configuration  func(childComplexity int) int
		Request        func(childComplexity int) int
		Response       func(childComplexity int) int
		RequestPlugin  func(childComplexity int) int
		ResponsePlugin func(childComplexity int) int
		Hotels         func(childComplexity int) int
		Zones          func(childComplexity int) int
		Cities         func(childComplexity int) int
		DockerId       func(childComplexity int) int
		Accesses       func(childComplexity int) int
	}

	Supplement struct {
		Code           func(childComplexity int) int
		Name           func(childComplexity int) int
		Description    func(childComplexity int) int
		SupplementType func(childComplexity int) int
		ChargeType     func(childComplexity int) int
		Mandatory      func(childComplexity int) int
		DurationType   func(childComplexity int) int
		Quantity       func(childComplexity int) int
		Unit           func(childComplexity int) int
		EffectiveDate  func(childComplexity int) int
		ExpireDate     func(childComplexity int) int
		Resort         func(childComplexity int) int
		Price          func(childComplexity int) int
	}

	Surcharge struct {
		ChargeType  func(childComplexity int) int
		Mandatory   func(childComplexity int) int
		Price       func(childComplexity int) int
		Description func(childComplexity int) int
	}

	Transactions struct {
		Request   func(childComplexity int) int
		Response  func(childComplexity int) int
		TimeStamp func(childComplexity int) int
	}

	Warning struct {
		Code        func(childComplexity int) int
		Type        func(childComplexity int) int
		Description func(childComplexity int) int
	}
}

type HotelOptionSearchResolver interface {
	AddOns(ctx context.Context, obj *domainHotelCommon.Option) (*AddOns, error)
}
type QueryResolver interface {
	HotelX(ctx context.Context) (*HotelXQuery, error)
}

func field_HotelSearch_stats_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["token"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["token"] = arg0
	return args, nil

}

func field_Query___type_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_Search_hotel_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["token"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["token"] = arg0
	var arg1 *HotelCriteriaSearchInput
	if tmp, ok := rawArgs["criteria"]; ok {
		var err error
		var ptr1 HotelCriteriaSearchInput
		if tmp != nil {
			ptr1, err = UnmarshalHotelCriteriaSearchInput(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["criteria"] = arg1
	var arg2 *domainHotelCommon.Settings
	if tmp, ok := rawArgs["settings"]; ok {
		var err error
		var ptr1 domainHotelCommon.Settings
		if tmp != nil {
			ptr1, err = UnmarshalHotelSettingsInput(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["settings"] = arg2
	var arg3 *search.Filter
	if tmp, ok := rawArgs["filter"]; ok {
		var err error
		var ptr1 search.Filter
		if tmp != nil {
			ptr1, err = UnmarshalFilterInput(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg3
	return args, nil

}

func field___Type_fields_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil

}

func field___Type_enumValues_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil

}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	switch typeName + "." + field {

	case "AddOn.key":
		if e.complexity.AddOn.Key == nil {
			break
		}

		return e.complexity.AddOn.Key(childComplexity), true

	case "AddOn.value":
		if e.complexity.AddOn.Value == nil {
			break
		}

		return e.complexity.AddOn.Value(childComplexity), true

	case "AddOns.distribute":
		if e.complexity.AddOns.Distribute == nil {
			break
		}

		return e.complexity.AddOns.Distribute(childComplexity), true

	case "AddOns.distribution":
		if e.complexity.AddOns.Distribution == nil {
			break
		}

		return e.complexity.AddOns.Distribution(childComplexity), true

	case "AuditData.transactions":
		if e.complexity.AuditData.Transactions == nil {
			break
		}

		return e.complexity.AuditData.Transactions(childComplexity), true

	case "AuditData.timeStamp":
		if e.complexity.AuditData.TimeStamp == nil {
			break
		}

		return e.complexity.AuditData.TimeStamp(childComplexity), true

	case "AuditData.processTime":
		if e.complexity.AuditData.ProcessTime == nil {
			break
		}

		return e.complexity.AuditData.ProcessTime(childComplexity), true

	case "Bed.type":
		if e.complexity.Bed.Type == nil {
			break
		}

		return e.complexity.Bed.Type(childComplexity), true

	case "Bed.description":
		if e.complexity.Bed.Description == nil {
			break
		}

		return e.complexity.Bed.Description(childComplexity), true

	case "Bed.count":
		if e.complexity.Bed.Count == nil {
			break
		}

		return e.complexity.Bed.Count(childComplexity), true

	case "Bed.shared":
		if e.complexity.Bed.Shared == nil {
			break
		}

		return e.complexity.Bed.Shared(childComplexity), true

	case "CancelPenalty.hoursBefore":
		if e.complexity.CancelPenalty.HoursBefore == nil {
			break
		}

		return e.complexity.CancelPenalty.HoursBefore(childComplexity), true

	case "CancelPenalty.penaltyType":
		if e.complexity.CancelPenalty.PenaltyType == nil {
			break
		}

		return e.complexity.CancelPenalty.PenaltyType(childComplexity), true

	case "CancelPenalty.currency":
		if e.complexity.CancelPenalty.Currency == nil {
			break
		}

		return e.complexity.CancelPenalty.Currency(childComplexity), true

	case "CancelPenalty.value":
		if e.complexity.CancelPenalty.Value == nil {
			break
		}

		return e.complexity.CancelPenalty.Value(childComplexity), true

	case "CancelPolicy.refundable":
		if e.complexity.CancelPolicy.Refundable == nil {
			break
		}

		return e.complexity.CancelPolicy.Refundable(childComplexity), true

	case "CancelPolicy.cancelPenalties":
		if e.complexity.CancelPolicy.CancelPenalties == nil {
			break
		}

		return e.complexity.CancelPolicy.CancelPenalties(childComplexity), true

	case "CriteriaSearch.checkIn":
		if e.complexity.CriteriaSearch.CheckIn == nil {
			break
		}

		return e.complexity.CriteriaSearch.CheckIn(childComplexity), true

	case "CriteriaSearch.checkOut":
		if e.complexity.CriteriaSearch.CheckOut == nil {
			break
		}

		return e.complexity.CriteriaSearch.CheckOut(childComplexity), true

	case "CriteriaSearch.hotels":
		if e.complexity.CriteriaSearch.Hotels == nil {
			break
		}

		return e.complexity.CriteriaSearch.Hotels(childComplexity), true

	case "CriteriaSearch.occupancies":
		if e.complexity.CriteriaSearch.Occupancies == nil {
			break
		}

		return e.complexity.CriteriaSearch.Occupancies(childComplexity), true

	case "CriteriaSearch.language":
		if e.complexity.CriteriaSearch.Language == nil {
			break
		}

		return e.complexity.CriteriaSearch.Language(childComplexity), true

	case "CriteriaSearch.currency":
		if e.complexity.CriteriaSearch.Currency == nil {
			break
		}

		return e.complexity.CriteriaSearch.Currency(childComplexity), true

	case "CriteriaSearch.nationality":
		if e.complexity.CriteriaSearch.Nationality == nil {
			break
		}

		return e.complexity.CriteriaSearch.Nationality(childComplexity), true

	case "CriteriaSearch.market":
		if e.complexity.CriteriaSearch.Market == nil {
			break
		}

		return e.complexity.CriteriaSearch.Market(childComplexity), true

	case "Error.code":
		if e.complexity.Error.Code == nil {
			break
		}

		return e.complexity.Error.Code(childComplexity), true

	case "Error.type":
		if e.complexity.Error.Type == nil {
			break
		}

		return e.complexity.Error.Type(childComplexity), true

	case "Error.description":
		if e.complexity.Error.Description == nil {
			break
		}

		return e.complexity.Error.Description(childComplexity), true

	case "Exchange.currency":
		if e.complexity.Exchange.Currency == nil {
			break
		}

		return e.complexity.Exchange.Currency(childComplexity), true

	case "Exchange.rate":
		if e.complexity.Exchange.Rate == nil {
			break
		}

		return e.complexity.Exchange.Rate(childComplexity), true

	case "HotelOptionSearch.supplierCode":
		if e.complexity.HotelOptionSearch.SupplierCode == nil {
			break
		}

		return e.complexity.HotelOptionSearch.SupplierCode(childComplexity), true

	case "HotelOptionSearch.accessCode":
		if e.complexity.HotelOptionSearch.AccessCode == nil {
			break
		}

		return e.complexity.HotelOptionSearch.AccessCode(childComplexity), true

	case "HotelOptionSearch.market":
		if e.complexity.HotelOptionSearch.Market == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Market(childComplexity), true

	case "HotelOptionSearch.hotelCode":
		if e.complexity.HotelOptionSearch.HotelCode == nil {
			break
		}

		return e.complexity.HotelOptionSearch.HotelCode(childComplexity), true

	case "HotelOptionSearch.hotelCodeSupplier":
		if e.complexity.HotelOptionSearch.HotelCodeSupplier == nil {
			break
		}

		return e.complexity.HotelOptionSearch.HotelCodeSupplier(childComplexity), true

	case "HotelOptionSearch.hotelName":
		if e.complexity.HotelOptionSearch.HotelName == nil {
			break
		}

		return e.complexity.HotelOptionSearch.HotelName(childComplexity), true

	case "HotelOptionSearch.boardCode":
		if e.complexity.HotelOptionSearch.BoardCode == nil {
			break
		}

		return e.complexity.HotelOptionSearch.BoardCode(childComplexity), true

	case "HotelOptionSearch.boardCodeSupplier":
		if e.complexity.HotelOptionSearch.BoardCodeSupplier == nil {
			break
		}

		return e.complexity.HotelOptionSearch.BoardCodeSupplier(childComplexity), true

	case "HotelOptionSearch.paymentType":
		if e.complexity.HotelOptionSearch.PaymentType == nil {
			break
		}

		return e.complexity.HotelOptionSearch.PaymentType(childComplexity), true

	case "HotelOptionSearch.status":
		if e.complexity.HotelOptionSearch.Status == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Status(childComplexity), true

	case "HotelOptionSearch.occupancies":
		if e.complexity.HotelOptionSearch.Occupancies == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Occupancies(childComplexity), true

	case "HotelOptionSearch.rooms":
		if e.complexity.HotelOptionSearch.Rooms == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Rooms(childComplexity), true

	case "HotelOptionSearch.price":
		if e.complexity.HotelOptionSearch.Price == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Price(childComplexity), true

	case "HotelOptionSearch.supplements":
		if e.complexity.HotelOptionSearch.Supplements == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Supplements(childComplexity), true

	case "HotelOptionSearch.surcharges":
		if e.complexity.HotelOptionSearch.Surcharges == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Surcharges(childComplexity), true

	case "HotelOptionSearch.rateRules":
		if e.complexity.HotelOptionSearch.RateRules == nil {
			break
		}

		return e.complexity.HotelOptionSearch.RateRules(childComplexity), true

	case "HotelOptionSearch.cancelPolicy":
		if e.complexity.HotelOptionSearch.CancelPolicy == nil {
			break
		}

		return e.complexity.HotelOptionSearch.CancelPolicy(childComplexity), true

	case "HotelOptionSearch.remarks":
		if e.complexity.HotelOptionSearch.Remarks == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Remarks(childComplexity), true

	case "HotelOptionSearch.addOns":
		if e.complexity.HotelOptionSearch.AddOns == nil {
			break
		}

		return e.complexity.HotelOptionSearch.AddOns(childComplexity), true

	case "HotelOptionSearch.token":
		if e.complexity.HotelOptionSearch.Token == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Token(childComplexity), true

	case "HotelOptionSearch.id":
		if e.complexity.HotelOptionSearch.Id == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Id(childComplexity), true

	case "HotelSearch.context":
		if e.complexity.HotelSearch.Context == nil {
			break
		}

		return e.complexity.HotelSearch.Context(childComplexity), true

	case "HotelSearch.stats":
		if e.complexity.HotelSearch.Stats == nil {
			break
		}

		args, err := field_HotelSearch_stats_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.HotelSearch.Stats(childComplexity, args["token"].(string)), true

	case "HotelSearch.auditData":
		if e.complexity.HotelSearch.AuditData == nil {
			break
		}

		return e.complexity.HotelSearch.AuditData(childComplexity), true

	case "HotelSearch.requestCriteria":
		if e.complexity.HotelSearch.RequestCriteria == nil {
			break
		}

		return e.complexity.HotelSearch.RequestCriteria(childComplexity), true

	case "HotelSearch.options":
		if e.complexity.HotelSearch.Options == nil {
			break
		}

		return e.complexity.HotelSearch.Options(childComplexity), true

	case "HotelSearch.errors":
		if e.complexity.HotelSearch.Errors == nil {
			break
		}

		return e.complexity.HotelSearch.Errors(childComplexity), true

	case "HotelSearch.warnings":
		if e.complexity.HotelSearch.Warnings == nil {
			break
		}

		return e.complexity.HotelSearch.Warnings(childComplexity), true

	case "HotelXQuery.search":
		if e.complexity.HotelXquery.Search == nil {
			break
		}

		return e.complexity.HotelXquery.Search(childComplexity), true

	case "HotelXQuery.searchStatusService":
		if e.complexity.HotelXquery.SearchStatusService == nil {
			break
		}

		return e.complexity.HotelXquery.SearchStatusService(childComplexity), true

	case "Markup.channel":
		if e.complexity.Markup.Channel == nil {
			break
		}

		return e.complexity.Markup.Channel(childComplexity), true

	case "Markup.currency":
		if e.complexity.Markup.Currency == nil {
			break
		}

		return e.complexity.Markup.Currency(childComplexity), true

	case "Markup.binding":
		if e.complexity.Markup.Binding == nil {
			break
		}

		return e.complexity.Markup.Binding(childComplexity), true

	case "Markup.net":
		if e.complexity.Markup.Net == nil {
			break
		}

		return e.complexity.Markup.Net(childComplexity), true

	case "Markup.gross":
		if e.complexity.Markup.Gross == nil {
			break
		}

		return e.complexity.Markup.Gross(childComplexity), true

	case "Markup.exchange":
		if e.complexity.Markup.Exchange == nil {
			break
		}

		return e.complexity.Markup.Exchange(childComplexity), true

	case "Markup.rules":
		if e.complexity.Markup.Rules == nil {
			break
		}

		return e.complexity.Markup.Rules(childComplexity), true

	case "Occupancy.id":
		if e.complexity.Occupancy.Id == nil {
			break
		}

		return e.complexity.Occupancy.Id(childComplexity), true

	case "Occupancy.paxes":
		if e.complexity.Occupancy.Paxes == nil {
			break
		}

		return e.complexity.Occupancy.Paxes(childComplexity), true

	case "Pax.age":
		if e.complexity.Pax.Age == nil {
			break
		}

		return e.complexity.Pax.Age(childComplexity), true

	case "Price.currency":
		if e.complexity.Price.Currency == nil {
			break
		}

		return e.complexity.Price.Currency(childComplexity), true

	case "Price.binding":
		if e.complexity.Price.Binding == nil {
			break
		}

		return e.complexity.Price.Binding(childComplexity), true

	case "Price.net":
		if e.complexity.Price.Net == nil {
			break
		}

		return e.complexity.Price.Net(childComplexity), true

	case "Price.gross":
		if e.complexity.Price.Gross == nil {
			break
		}

		return e.complexity.Price.Gross(childComplexity), true

	case "Price.exchange":
		if e.complexity.Price.Exchange == nil {
			break
		}

		return e.complexity.Price.Exchange(childComplexity), true

	case "Price.markups":
		if e.complexity.Price.Markups == nil {
			break
		}

		return e.complexity.Price.Markups(childComplexity), true

	case "PriceBreakdown.effectiveDate":
		if e.complexity.PriceBreakdown.EffectiveDate == nil {
			break
		}

		return e.complexity.PriceBreakdown.EffectiveDate(childComplexity), true

	case "PriceBreakdown.expireDate":
		if e.complexity.PriceBreakdown.ExpireDate == nil {
			break
		}

		return e.complexity.PriceBreakdown.ExpireDate(childComplexity), true

	case "PriceBreakdown.price":
		if e.complexity.PriceBreakdown.Price == nil {
			break
		}

		return e.complexity.PriceBreakdown.Price(childComplexity), true

	case "Promotion.code":
		if e.complexity.Promotion.Code == nil {
			break
		}

		return e.complexity.Promotion.Code(childComplexity), true

	case "Promotion.name":
		if e.complexity.Promotion.Name == nil {
			break
		}

		return e.complexity.Promotion.Name(childComplexity), true

	case "Promotion.effectiveDate":
		if e.complexity.Promotion.EffectiveDate == nil {
			break
		}

		return e.complexity.Promotion.EffectiveDate(childComplexity), true

	case "Promotion.expireDate":
		if e.complexity.Promotion.ExpireDate == nil {
			break
		}

		return e.complexity.Promotion.ExpireDate(childComplexity), true

	case "Query.hotelX":
		if e.complexity.Query.HotelX == nil {
			break
		}

		return e.complexity.Query.HotelX(childComplexity), true

	case "RatePlan.code":
		if e.complexity.RatePlan.Code == nil {
			break
		}

		return e.complexity.RatePlan.Code(childComplexity), true

	case "RatePlan.name":
		if e.complexity.RatePlan.Name == nil {
			break
		}

		return e.complexity.RatePlan.Name(childComplexity), true

	case "RatePlan.effectiveDate":
		if e.complexity.RatePlan.EffectiveDate == nil {
			break
		}

		return e.complexity.RatePlan.EffectiveDate(childComplexity), true

	case "RatePlan.expireDate":
		if e.complexity.RatePlan.ExpireDate == nil {
			break
		}

		return e.complexity.RatePlan.ExpireDate(childComplexity), true

	case "Resort.code":
		if e.complexity.Resort.Code == nil {
			break
		}

		return e.complexity.Resort.Code(childComplexity), true

	case "Resort.name":
		if e.complexity.Resort.Name == nil {
			break
		}

		return e.complexity.Resort.Name(childComplexity), true

	case "Resort.description":
		if e.complexity.Resort.Description == nil {
			break
		}

		return e.complexity.Resort.Description(childComplexity), true

	case "Room.occupancyRefId":
		if e.complexity.Room.OccupancyRefId == nil {
			break
		}

		return e.complexity.Room.OccupancyRefId(childComplexity), true

	case "Room.code":
		if e.complexity.Room.Code == nil {
			break
		}

		return e.complexity.Room.Code(childComplexity), true

	case "Room.description":
		if e.complexity.Room.Description == nil {
			break
		}

		return e.complexity.Room.Description(childComplexity), true

	case "Room.refundable":
		if e.complexity.Room.Refundable == nil {
			break
		}

		return e.complexity.Room.Refundable(childComplexity), true

	case "Room.units":
		if e.complexity.Room.Units == nil {
			break
		}

		return e.complexity.Room.Units(childComplexity), true

	case "Room.roomPrice":
		if e.complexity.Room.RoomPrice == nil {
			break
		}

		return e.complexity.Room.RoomPrice(childComplexity), true

	case "Room.beds":
		if e.complexity.Room.Beds == nil {
			break
		}

		return e.complexity.Room.Beds(childComplexity), true

	case "Room.ratePlans":
		if e.complexity.Room.RatePlans == nil {
			break
		}

		return e.complexity.Room.RatePlans(childComplexity), true

	case "Room.promotions":
		if e.complexity.Room.Promotions == nil {
			break
		}

		return e.complexity.Room.Promotions(childComplexity), true

	case "RoomCriteria.paxes":
		if e.complexity.RoomCriteria.Paxes == nil {
			break
		}

		return e.complexity.RoomCriteria.Paxes(childComplexity), true

	case "RoomPrice.price":
		if e.complexity.RoomPrice.Price == nil {
			break
		}

		return e.complexity.RoomPrice.Price(childComplexity), true

	case "RoomPrice.breakdown":
		if e.complexity.RoomPrice.Breakdown == nil {
			break
		}

		return e.complexity.RoomPrice.Breakdown(childComplexity), true

	case "Rule.id":
		if e.complexity.Rule.Id == nil {
			break
		}

		return e.complexity.Rule.Id(childComplexity), true

	case "Rule.name":
		if e.complexity.Rule.Name == nil {
			break
		}

		return e.complexity.Rule.Name(childComplexity), true

	case "Rule.type":
		if e.complexity.Rule.Type == nil {
			break
		}

		return e.complexity.Rule.Type(childComplexity), true

	case "Rule.value":
		if e.complexity.Rule.Value == nil {
			break
		}

		return e.complexity.Rule.Value(childComplexity), true

	case "Search.hotel":
		if e.complexity.Search.Hotel == nil {
			break
		}

		args, err := field_Search_hotel_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Search.Hotel(childComplexity, args["token"].(*string), args["criteria"].(*HotelCriteriaSearchInput), args["settings"].(*domainHotelCommon.Settings), args["filter"].(*search.Filter)), true

	case "ServiceStatus.code":
		if e.complexity.ServiceStatus.Code == nil {
			break
		}

		return e.complexity.ServiceStatus.Code(childComplexity), true

	case "ServiceStatus.type":
		if e.complexity.ServiceStatus.Type == nil {
			break
		}

		return e.complexity.ServiceStatus.Type(childComplexity), true

	case "ServiceStatus.description":
		if e.complexity.ServiceStatus.Description == nil {
			break
		}

		return e.complexity.ServiceStatus.Description(childComplexity), true

	case "Stat.start":
		if e.complexity.Stat.Start == nil {
			break
		}

		return e.complexity.Stat.Start(childComplexity), true

	case "Stat.end":
		if e.complexity.Stat.End == nil {
			break
		}

		return e.complexity.Stat.End(childComplexity), true

	case "Stat.duration":
		if e.complexity.Stat.Duration == nil {
			break
		}

		return e.complexity.Stat.Duration(childComplexity), true

	case "StatAccess.name":
		if e.complexity.StatAccess.Name == nil {
			break
		}

		return e.complexity.StatAccess.Name(childComplexity), true

	case "StatAccess.total":
		if e.complexity.StatAccess.Total == nil {
			break
		}

		return e.complexity.StatAccess.Total(childComplexity), true

	case "StatAccess.staticConfiguration":
		if e.complexity.StatAccess.StaticConfiguration == nil {
			break
		}

		return e.complexity.StatAccess.StaticConfiguration(childComplexity), true

	case "StatAccess.hotels":
		if e.complexity.StatAccess.Hotels == nil {
			break
		}

		return e.complexity.StatAccess.Hotels(childComplexity), true

	case "StatAccess.zones":
		if e.complexity.StatAccess.Zones == nil {
			break
		}

		return e.complexity.StatAccess.Zones(childComplexity), true

	case "StatAccess.cities":
		if e.complexity.StatAccess.Cities == nil {
			break
		}

		return e.complexity.StatAccess.Cities(childComplexity), true

	case "StatAccess.requestAccess":
		if e.complexity.StatAccess.RequestAccess == nil {
			break
		}

		return e.complexity.StatAccess.RequestAccess(childComplexity), true

	case "StatAccess.responseAccess":
		if e.complexity.StatAccess.ResponseAccess == nil {
			break
		}

		return e.complexity.StatAccess.ResponseAccess(childComplexity), true

	case "StatAccess.transactions":
		if e.complexity.StatAccess.Transactions == nil {
			break
		}

		return e.complexity.StatAccess.Transactions(childComplexity), true

	case "StatAccess.plugins":
		if e.complexity.StatAccess.Plugins == nil {
			break
		}

		return e.complexity.StatAccess.Plugins(childComplexity), true

	case "StatPlugin.name":
		if e.complexity.StatPlugin.Name == nil {
			break
		}

		return e.complexity.StatPlugin.Name(childComplexity), true

	case "StatPlugin.total":
		if e.complexity.StatPlugin.Total == nil {
			break
		}

		return e.complexity.StatPlugin.Total(childComplexity), true

	case "StatTransaction.reference":
		if e.complexity.StatTransaction.Reference == nil {
			break
		}

		return e.complexity.StatTransaction.Reference(childComplexity), true

	case "StatTransaction.total":
		if e.complexity.StatTransaction.Total == nil {
			break
		}

		return e.complexity.StatTransaction.Total(childComplexity), true

	case "StatTransaction.buildRequest":
		if e.complexity.StatTransaction.BuildRequest == nil {
			break
		}

		return e.complexity.StatTransaction.BuildRequest(childComplexity), true

	case "StatTransaction.workerCommunication":
		if e.complexity.StatTransaction.WorkerCommunication == nil {
			break
		}

		return e.complexity.StatTransaction.WorkerCommunication(childComplexity), true

	case "StatTransaction.parseResponse":
		if e.complexity.StatTransaction.ParseResponse == nil {
			break
		}

		return e.complexity.StatTransaction.ParseResponse(childComplexity), true

	case "StatsRequest.total":
		if e.complexity.StatsRequest.Total == nil {
			break
		}

		return e.complexity.StatsRequest.Total(childComplexity), true

	case "StatsRequest.validation":
		if e.complexity.StatsRequest.Validation == nil {
			break
		}

		return e.complexity.StatsRequest.Validation(childComplexity), true

	case "StatsRequest.process":
		if e.complexity.StatsRequest.Process == nil {
			break
		}

		return e.complexity.StatsRequest.Process(childComplexity), true

	case "StatsRequest.configuration":
		if e.complexity.StatsRequest.Configuration == nil {
			break
		}

		return e.complexity.StatsRequest.Configuration(childComplexity), true

	case "StatsRequest.request":
		if e.complexity.StatsRequest.Request == nil {
			break
		}

		return e.complexity.StatsRequest.Request(childComplexity), true

	case "StatsRequest.response":
		if e.complexity.StatsRequest.Response == nil {
			break
		}

		return e.complexity.StatsRequest.Response(childComplexity), true

	case "StatsRequest.requestPlugin":
		if e.complexity.StatsRequest.RequestPlugin == nil {
			break
		}

		return e.complexity.StatsRequest.RequestPlugin(childComplexity), true

	case "StatsRequest.responsePlugin":
		if e.complexity.StatsRequest.ResponsePlugin == nil {
			break
		}

		return e.complexity.StatsRequest.ResponsePlugin(childComplexity), true

	case "StatsRequest.hotels":
		if e.complexity.StatsRequest.Hotels == nil {
			break
		}

		return e.complexity.StatsRequest.Hotels(childComplexity), true

	case "StatsRequest.zones":
		if e.complexity.StatsRequest.Zones == nil {
			break
		}

		return e.complexity.StatsRequest.Zones(childComplexity), true

	case "StatsRequest.cities":
		if e.complexity.StatsRequest.Cities == nil {
			break
		}

		return e.complexity.StatsRequest.Cities(childComplexity), true

	case "StatsRequest.dockerID":
		if e.complexity.StatsRequest.DockerId == nil {
			break
		}

		return e.complexity.StatsRequest.DockerId(childComplexity), true

	case "StatsRequest.Accesses":
		if e.complexity.StatsRequest.Accesses == nil {
			break
		}

		return e.complexity.StatsRequest.Accesses(childComplexity), true

	case "Supplement.code":
		if e.complexity.Supplement.Code == nil {
			break
		}

		return e.complexity.Supplement.Code(childComplexity), true

	case "Supplement.name":
		if e.complexity.Supplement.Name == nil {
			break
		}

		return e.complexity.Supplement.Name(childComplexity), true

	case "Supplement.description":
		if e.complexity.Supplement.Description == nil {
			break
		}

		return e.complexity.Supplement.Description(childComplexity), true

	case "Supplement.supplementType":
		if e.complexity.Supplement.SupplementType == nil {
			break
		}

		return e.complexity.Supplement.SupplementType(childComplexity), true

	case "Supplement.chargeType":
		if e.complexity.Supplement.ChargeType == nil {
			break
		}

		return e.complexity.Supplement.ChargeType(childComplexity), true

	case "Supplement.mandatory":
		if e.complexity.Supplement.Mandatory == nil {
			break
		}

		return e.complexity.Supplement.Mandatory(childComplexity), true

	case "Supplement.durationType":
		if e.complexity.Supplement.DurationType == nil {
			break
		}

		return e.complexity.Supplement.DurationType(childComplexity), true

	case "Supplement.quantity":
		if e.complexity.Supplement.Quantity == nil {
			break
		}

		return e.complexity.Supplement.Quantity(childComplexity), true

	case "Supplement.unit":
		if e.complexity.Supplement.Unit == nil {
			break
		}

		return e.complexity.Supplement.Unit(childComplexity), true

	case "Supplement.effectiveDate":
		if e.complexity.Supplement.EffectiveDate == nil {
			break
		}

		return e.complexity.Supplement.EffectiveDate(childComplexity), true

	case "Supplement.expireDate":
		if e.complexity.Supplement.ExpireDate == nil {
			break
		}

		return e.complexity.Supplement.ExpireDate(childComplexity), true

	case "Supplement.resort":
		if e.complexity.Supplement.Resort == nil {
			break
		}

		return e.complexity.Supplement.Resort(childComplexity), true

	case "Supplement.price":
		if e.complexity.Supplement.Price == nil {
			break
		}

		return e.complexity.Supplement.Price(childComplexity), true

	case "Surcharge.chargeType":
		if e.complexity.Surcharge.ChargeType == nil {
			break
		}

		return e.complexity.Surcharge.ChargeType(childComplexity), true

	case "Surcharge.mandatory":
		if e.complexity.Surcharge.Mandatory == nil {
			break
		}

		return e.complexity.Surcharge.Mandatory(childComplexity), true

	case "Surcharge.price":
		if e.complexity.Surcharge.Price == nil {
			break
		}

		return e.complexity.Surcharge.Price(childComplexity), true

	case "Surcharge.description":
		if e.complexity.Surcharge.Description == nil {
			break
		}

		return e.complexity.Surcharge.Description(childComplexity), true

	case "Transactions.request":
		if e.complexity.Transactions.Request == nil {
			break
		}

		return e.complexity.Transactions.Request(childComplexity), true

	case "Transactions.response":
		if e.complexity.Transactions.Response == nil {
			break
		}

		return e.complexity.Transactions.Response(childComplexity), true

	case "Transactions.timeStamp":
		if e.complexity.Transactions.TimeStamp == nil {
			break
		}

		return e.complexity.Transactions.TimeStamp(childComplexity), true

	case "Warning.code":
		if e.complexity.Warning.Code == nil {
			break
		}

		return e.complexity.Warning.Code(childComplexity), true

	case "Warning.type":
		if e.complexity.Warning.Type == nil {
			break
		}

		return e.complexity.Warning.Type(childComplexity), true

	case "Warning.description":
		if e.complexity.Warning.Description == nil {
			break
		}

		return e.complexity.Warning.Description(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	return graphql.ErrorResponse(ctx, "mutations are not supported")
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

var addOnImplementors = []string{"AddOn"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AddOn(ctx context.Context, sel ast.SelectionSet, obj *AddOn) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, addOnImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddOn")
		case "key":
			out.Values[i] = ec._AddOn_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "value":
			out.Values[i] = ec._AddOn_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AddOn_key(ctx context.Context, field graphql.CollectedField, obj *AddOn) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddOn",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AddOn_value(ctx context.Context, field graphql.CollectedField, obj *AddOn) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddOn",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var addOnsImplementors = []string{"AddOns"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AddOns(ctx context.Context, sel ast.SelectionSet, obj *AddOns) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, addOnsImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddOns")
		case "distribute":
			out.Values[i] = ec._AddOns_distribute(ctx, field, obj)
		case "distribution":
			out.Values[i] = ec._AddOns_distribution(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AddOns_distribute(ctx context.Context, field graphql.CollectedField, obj *AddOns) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddOns",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distribute, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _AddOns_distribution(ctx context.Context, field graphql.CollectedField, obj *AddOns) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AddOns",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distribution, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AddOn)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._AddOn(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var auditDataImplementors = []string{"AuditData"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AuditData(ctx context.Context, sel ast.SelectionSet, obj *common.AuditData) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, auditDataImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuditData")
		case "transactions":
			out.Values[i] = ec._AuditData_transactions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "timeStamp":
			out.Values[i] = ec._AuditData_timeStamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "processTime":
			out.Values[i] = ec._AuditData_processTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AuditData_transactions(ctx context.Context, field graphql.CollectedField, obj *common.AuditData) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AuditData",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Transactions, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]common.Transactions)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Transactions(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _AuditData_timeStamp(ctx context.Context, field graphql.CollectedField, obj *common.AuditData) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AuditData",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeStamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _AuditData_processTime(ctx context.Context, field graphql.CollectedField, obj *common.AuditData) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AuditData",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessTime, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalFloat(res)
}

var bedImplementors = []string{"Bed"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Bed(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Bed) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, bedImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Bed")
		case "type":
			out.Values[i] = ec._Bed_type(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Bed_description(ctx, field, obj)
		case "count":
			out.Values[i] = ec._Bed_count(ctx, field, obj)
		case "shared":
			out.Values[i] = ec._Bed_shared(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Bed_type(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Bed) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Bed",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Bed_description(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Bed) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Bed",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Bed_count(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Bed) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Bed",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Bed_shared(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Bed) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Bed",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Shared, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalBoolean(*res)
}

var cancelPenaltyImplementors = []string{"CancelPenalty"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _CancelPenalty(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.CancelPenalty) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, cancelPenaltyImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CancelPenalty")
		case "hoursBefore":
			out.Values[i] = ec._CancelPenalty_hoursBefore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "penaltyType":
			out.Values[i] = ec._CancelPenalty_penaltyType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "currency":
			out.Values[i] = ec._CancelPenalty_currency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "value":
			out.Values[i] = ec._CancelPenalty_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _CancelPenalty_hoursBefore(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.CancelPenalty) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "CancelPenalty",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HoursBefore, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _CancelPenalty_penaltyType(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.CancelPenalty) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "CancelPenalty",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.CancelPenaltyType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _CancelPenalty_currency(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.CancelPenalty) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "CancelPenalty",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _CancelPenalty_value(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.CancelPenalty) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "CancelPenalty",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalFloat(res)
}

var cancelPolicyImplementors = []string{"CancelPolicy"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _CancelPolicy(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.CancelPolicy) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, cancelPolicyImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CancelPolicy")
		case "refundable":
			out.Values[i] = ec._CancelPolicy_refundable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "cancelPenalties":
			out.Values[i] = ec._CancelPolicy_cancelPenalties(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _CancelPolicy_refundable(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.CancelPolicy) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "CancelPolicy",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Refundable, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _CancelPolicy_cancelPenalties(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.CancelPolicy) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "CancelPolicy",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CancelPenalties, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.CancelPenalty)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._CancelPenalty(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var criteriaSearchImplementors = []string{"CriteriaSearch"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _CriteriaSearch(ctx context.Context, sel ast.SelectionSet, obj *CriteriaSearch) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, criteriaSearchImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CriteriaSearch")
		case "checkIn":
			out.Values[i] = ec._CriteriaSearch_checkIn(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "checkOut":
			out.Values[i] = ec._CriteriaSearch_checkOut(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "hotels":
			out.Values[i] = ec._CriteriaSearch_hotels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "occupancies":
			out.Values[i] = ec._CriteriaSearch_occupancies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "language":
			out.Values[i] = ec._CriteriaSearch_language(ctx, field, obj)
		case "currency":
			out.Values[i] = ec._CriteriaSearch_currency(ctx, field, obj)
		case "nationality":
			out.Values[i] = ec._CriteriaSearch_nationality(ctx, field, obj)
		case "market":
			out.Values[i] = ec._CriteriaSearch_market(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _CriteriaSearch_checkIn(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "CriteriaSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CheckIn, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _CriteriaSearch_checkOut(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "CriteriaSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CheckOut, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _CriteriaSearch_hotels(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "CriteriaSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hotels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _CriteriaSearch_occupancies(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "CriteriaSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Occupancies, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]RoomCriteria)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._RoomCriteria(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _CriteriaSearch_language(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "CriteriaSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Language, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _CriteriaSearch_currency(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "CriteriaSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _CriteriaSearch_nationality(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "CriteriaSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nationality, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _CriteriaSearch_market(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "CriteriaSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Market, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var errorImplementors = []string{"Error"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Error(ctx context.Context, sel ast.SelectionSet, obj *common.AdviseMessage) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, errorImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Error")
		case "code":
			out.Values[i] = ec._Error_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec._Error_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._Error_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Error_code(ctx context.Context, field graphql.CollectedField, obj *common.AdviseMessage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Error",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Error_type(ctx context.Context, field graphql.CollectedField, obj *common.AdviseMessage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Error",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Error_description(ctx context.Context, field graphql.CollectedField, obj *common.AdviseMessage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Error",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var exchangeImplementors = []string{"Exchange"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Exchange(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Exchange) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, exchangeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Exchange")
		case "currency":
			out.Values[i] = ec._Exchange_currency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "rate":
			out.Values[i] = ec._Exchange_rate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Exchange_currency(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Exchange) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Exchange",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Exchange_rate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Exchange) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Exchange",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rate, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalFloat(res)
}

var hotelOptionSearchImplementors = []string{"HotelOptionSearch", "BookableOptionSearch"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _HotelOptionSearch(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Option) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, hotelOptionSearchImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HotelOptionSearch")
		case "supplierCode":
			out.Values[i] = ec._HotelOptionSearch_supplierCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "accessCode":
			out.Values[i] = ec._HotelOptionSearch_accessCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "market":
			out.Values[i] = ec._HotelOptionSearch_market(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "hotelCode":
			out.Values[i] = ec._HotelOptionSearch_hotelCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "hotelCodeSupplier":
			out.Values[i] = ec._HotelOptionSearch_hotelCodeSupplier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "hotelName":
			out.Values[i] = ec._HotelOptionSearch_hotelName(ctx, field, obj)
		case "boardCode":
			out.Values[i] = ec._HotelOptionSearch_boardCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "boardCodeSupplier":
			out.Values[i] = ec._HotelOptionSearch_boardCodeSupplier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "paymentType":
			out.Values[i] = ec._HotelOptionSearch_paymentType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._HotelOptionSearch_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "occupancies":
			out.Values[i] = ec._HotelOptionSearch_occupancies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "rooms":
			out.Values[i] = ec._HotelOptionSearch_rooms(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "price":
			out.Values[i] = ec._HotelOptionSearch_price(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "supplements":
			out.Values[i] = ec._HotelOptionSearch_supplements(ctx, field, obj)
		case "surcharges":
			out.Values[i] = ec._HotelOptionSearch_surcharges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "rateRules":
			out.Values[i] = ec._HotelOptionSearch_rateRules(ctx, field, obj)
		case "cancelPolicy":
			out.Values[i] = ec._HotelOptionSearch_cancelPolicy(ctx, field, obj)
		case "remarks":
			out.Values[i] = ec._HotelOptionSearch_remarks(ctx, field, obj)
		case "addOns":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._HotelOptionSearch_addOns(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "token":
			out.Values[i] = ec._HotelOptionSearch_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "id":
			out.Values[i] = ec._HotelOptionSearch_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _HotelOptionSearch_supplierCode(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelOptionSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Supplier, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _HotelOptionSearch_accessCode(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelOptionSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Access, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _HotelOptionSearch_market(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelOptionSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Market, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _HotelOptionSearch_hotelCode(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelOptionSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HotelCode, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _HotelOptionSearch_hotelCodeSupplier(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelOptionSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HotelCodeSupplier(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _HotelOptionSearch_hotelName(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelOptionSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HotelName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _HotelOptionSearch_boardCode(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelOptionSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BoardCode, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _HotelOptionSearch_boardCodeSupplier(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelOptionSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BoardCodeOriginal, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _HotelOptionSearch_paymentType(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelOptionSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PaymentType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.PaymentType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _HotelOptionSearch_status(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelOptionSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.StatusType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _HotelOptionSearch_occupancies(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelOptionSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Occupancies, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Occupancy)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Occupancy(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _HotelOptionSearch_rooms(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelOptionSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rooms, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Room)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Room(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _HotelOptionSearch_price(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelOptionSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.Price)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Price(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _HotelOptionSearch_supplements(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelOptionSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Supplements, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*domainHotelCommon.Supplement)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._Supplement(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _HotelOptionSearch_surcharges(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelOptionSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Surcharges, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Surcharge)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Surcharge(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _HotelOptionSearch_rateRules(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelOptionSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RateRules, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]access.RateRulesType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return res[idx1]
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _HotelOptionSearch_cancelPolicy(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelOptionSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CancelPolicy, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*domainHotelCommon.CancelPolicy)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._CancelPolicy(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _HotelOptionSearch_remarks(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelOptionSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Remarks, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _HotelOptionSearch_addOns(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelOptionSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.HotelOptionSearch().AddOns(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddOns)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AddOns(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _HotelOptionSearch_token(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelOptionSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _HotelOptionSearch_id(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelOptionSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OptionID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var hotelSearchImplementors = []string{"HotelSearch", "Response"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _HotelSearch(ctx context.Context, sel ast.SelectionSet, obj *HotelSearch) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, hotelSearchImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HotelSearch")
		case "context":
			out.Values[i] = ec._HotelSearch_context(ctx, field, obj)
		case "stats":
			out.Values[i] = ec._HotelSearch_stats(ctx, field, obj)
		case "auditData":
			out.Values[i] = ec._HotelSearch_auditData(ctx, field, obj)
		case "requestCriteria":
			out.Values[i] = ec._HotelSearch_requestCriteria(ctx, field, obj)
		case "options":
			out.Values[i] = ec._HotelSearch_options(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._HotelSearch_errors(ctx, field, obj)
		case "warnings":
			out.Values[i] = ec._HotelSearch_warnings(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _HotelSearch_context(ctx context.Context, field graphql.CollectedField, obj *HotelSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Context, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _HotelSearch_stats(ctx context.Context, field graphql.CollectedField, obj *HotelSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_HotelSearch_stats_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "HotelSearch",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stats, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*StatsRequest)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._StatsRequest(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _HotelSearch_auditData(ctx context.Context, field graphql.CollectedField, obj *HotelSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuditData, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*common.AuditData)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AuditData(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _HotelSearch_requestCriteria(ctx context.Context, field graphql.CollectedField, obj *HotelSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestCriteria, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CriteriaSearch)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._CriteriaSearch(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _HotelSearch_options(ctx context.Context, field graphql.CollectedField, obj *HotelSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Options, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*domainHotelCommon.Option)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._HotelOptionSearch(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _HotelSearch_errors(ctx context.Context, field graphql.CollectedField, obj *HotelSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]common.AdviseMessage)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Error(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _HotelSearch_warnings(ctx context.Context, field graphql.CollectedField, obj *HotelSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelSearch",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Warnings, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]common.AdviseMessage)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Warning(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var hotelXQueryImplementors = []string{"HotelXQuery"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _HotelXQuery(ctx context.Context, sel ast.SelectionSet, obj *HotelXQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, hotelXQueryImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HotelXQuery")
		case "search":
			out.Values[i] = ec._HotelXQuery_search(ctx, field, obj)
		case "searchStatusService":
			out.Values[i] = ec._HotelXQuery_searchStatusService(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _HotelXQuery_search(ctx context.Context, field graphql.CollectedField, obj *HotelXQuery) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelXQuery",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Search, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*HotelSearch)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._HotelSearch(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _HotelXQuery_searchStatusService(ctx context.Context, field graphql.CollectedField, obj *HotelXQuery) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "HotelXQuery",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SearchStatusService, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._ServiceStatus(ctx, field.Selections, &res)
}

var markupImplementors = []string{"Markup", "Priceable"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Markup(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Markup) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, markupImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Markup")
		case "channel":
			out.Values[i] = ec._Markup_channel(ctx, field, obj)
		case "currency":
			out.Values[i] = ec._Markup_currency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "binding":
			out.Values[i] = ec._Markup_binding(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "net":
			out.Values[i] = ec._Markup_net(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "gross":
			out.Values[i] = ec._Markup_gross(ctx, field, obj)
		case "exchange":
			out.Values[i] = ec._Markup_exchange(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "rules":
			out.Values[i] = ec._Markup_rules(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Markup_channel(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Markup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Markup",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Channel, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Markup_currency(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Markup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Markup",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Markup_binding(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Markup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Markup",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Binding, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _Markup_net(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Markup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Markup",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Net, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalFloat(res)
}

// nolint: vetshadow
func (ec *executionContext) _Markup_gross(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Markup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Markup",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gross, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalFloat(res)
}

// nolint: vetshadow
func (ec *executionContext) _Markup_exchange(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Markup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Markup",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exchange, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.Exchange)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Exchange(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Markup_rules(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Markup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Markup",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rules, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Rule)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Rule(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var occupancyImplementors = []string{"Occupancy"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Occupancy(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Occupancy) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, occupancyImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Occupancy")
		case "id":
			out.Values[i] = ec._Occupancy_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "paxes":
			out.Values[i] = ec._Occupancy_paxes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Occupancy_id(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Occupancy) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Occupancy",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _Occupancy_paxes(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Occupancy) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Occupancy",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Paxes, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Pax)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Pax(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var paxImplementors = []string{"Pax"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Pax(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Pax) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, paxImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Pax")
		case "age":
			out.Values[i] = ec._Pax_age(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Pax_age(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Pax) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Pax",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Age, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

var priceImplementors = []string{"Price", "Priceable"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Price(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Price) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, priceImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Price")
		case "currency":
			out.Values[i] = ec._Price_currency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "binding":
			out.Values[i] = ec._Price_binding(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "net":
			out.Values[i] = ec._Price_net(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "gross":
			out.Values[i] = ec._Price_gross(ctx, field, obj)
		case "exchange":
			out.Values[i] = ec._Price_exchange(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "markups":
			out.Values[i] = ec._Price_markups(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Price_currency(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Price) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Price",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Price_binding(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Price) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Price",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Binding, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _Price_net(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Price) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Price",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Net, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalFloat(res)
}

// nolint: vetshadow
func (ec *executionContext) _Price_gross(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Price) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Price",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gross, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalFloat(res)
}

// nolint: vetshadow
func (ec *executionContext) _Price_exchange(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Price) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Price",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exchange, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.Exchange)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Exchange(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Price_markups(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Price) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Price",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Markups, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Markup)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Markup(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var priceBreakdownImplementors = []string{"PriceBreakdown"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _PriceBreakdown(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.PriceBreakDown) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, priceBreakdownImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PriceBreakdown")
		case "effectiveDate":
			out.Values[i] = ec._PriceBreakdown_effectiveDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "expireDate":
			out.Values[i] = ec._PriceBreakdown_expireDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "price":
			out.Values[i] = ec._PriceBreakdown_price(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _PriceBreakdown_effectiveDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.PriceBreakDown) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PriceBreakdown",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EffectiveDate, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _PriceBreakdown_expireDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.PriceBreakDown) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PriceBreakdown",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpireDate, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _PriceBreakdown_price(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.PriceBreakDown) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PriceBreakdown",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.Price)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Price(ctx, field.Selections, &res)
}

var promotionImplementors = []string{"Promotion"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Promotion(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Promotion) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, promotionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Promotion")
		case "code":
			out.Values[i] = ec._Promotion_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._Promotion_name(ctx, field, obj)
		case "effectiveDate":
			out.Values[i] = ec._Promotion_effectiveDate(ctx, field, obj)
		case "expireDate":
			out.Values[i] = ec._Promotion_expireDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Promotion_code(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Promotion) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Promotion",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Promotion_name(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Promotion) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Promotion",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Promotion_effectiveDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Promotion) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Promotion",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EffectiveDate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Promotion_expireDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Promotion) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Promotion",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpireDate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var queryImplementors = []string{"Query"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "hotelX":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_hotelX(ctx, field)
				wg.Done()
			}(i, field)
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Query_hotelX(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().HotelX(rctx)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*HotelXQuery)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._HotelXQuery(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query___type_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Schema(ctx, field.Selections, res)
}

var ratePlanImplementors = []string{"RatePlan"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _RatePlan(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.RatePlan) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, ratePlanImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RatePlan")
		case "code":
			out.Values[i] = ec._RatePlan_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._RatePlan_name(ctx, field, obj)
		case "effectiveDate":
			out.Values[i] = ec._RatePlan_effectiveDate(ctx, field, obj)
		case "expireDate":
			out.Values[i] = ec._RatePlan_expireDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _RatePlan_code(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.RatePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "RatePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _RatePlan_name(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.RatePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "RatePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _RatePlan_effectiveDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.RatePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "RatePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EffectiveDate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _RatePlan_expireDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.RatePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "RatePlan",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpireDate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var resortImplementors = []string{"Resort"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Resort(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Resort) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resortImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Resort")
		case "code":
			out.Values[i] = ec._Resort_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._Resort_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Resort_description(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Resort_code(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Resort) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Resort",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Resort_name(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Resort) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Resort",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Resort_description(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Resort) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Resort",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var roomImplementors = []string{"Room"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Room(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Room) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, roomImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Room")
		case "occupancyRefId":
			out.Values[i] = ec._Room_occupancyRefId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "code":
			out.Values[i] = ec._Room_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._Room_description(ctx, field, obj)
		case "refundable":
			out.Values[i] = ec._Room_refundable(ctx, field, obj)
		case "units":
			out.Values[i] = ec._Room_units(ctx, field, obj)
		case "roomPrice":
			out.Values[i] = ec._Room_roomPrice(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "beds":
			out.Values[i] = ec._Room_beds(ctx, field, obj)
		case "ratePlans":
			out.Values[i] = ec._Room_ratePlans(ctx, field, obj)
		case "promotions":
			out.Values[i] = ec._Room_promotions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Room_occupancyRefId(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Room",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OccupancyRefID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _Room_code(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Room",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Room_description(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Room",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Room_refundable(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Room",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Refundable, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalBoolean(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Room_units(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Room",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Units, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Room_roomPrice(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Room",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoomPrice, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.RoomPrice)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._RoomPrice(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Room_beds(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Room",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Beds, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Bed)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Bed(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Room_ratePlans(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Room",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RatePlans, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.RatePlan)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._RatePlan(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Room_promotions(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Room",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Promotions, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Promotion)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Promotion(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var roomCriteriaImplementors = []string{"RoomCriteria"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _RoomCriteria(ctx context.Context, sel ast.SelectionSet, obj *RoomCriteria) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, roomCriteriaImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoomCriteria")
		case "paxes":
			out.Values[i] = ec._RoomCriteria_paxes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _RoomCriteria_paxes(ctx context.Context, field graphql.CollectedField, obj *RoomCriteria) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "RoomCriteria",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Paxes, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Pax)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Pax(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var roomPriceImplementors = []string{"RoomPrice"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _RoomPrice(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.RoomPrice) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, roomPriceImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoomPrice")
		case "price":
			out.Values[i] = ec._RoomPrice_price(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "breakdown":
			out.Values[i] = ec._RoomPrice_breakdown(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _RoomPrice_price(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.RoomPrice) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "RoomPrice",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.Price)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Price(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _RoomPrice_breakdown(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.RoomPrice) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "RoomPrice",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Breakdown, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.PriceBreakDown)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._PriceBreakdown(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var ruleImplementors = []string{"Rule"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Rule(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Rule) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, ruleImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Rule")
		case "id":
			out.Values[i] = ec._Rule_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._Rule_name(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Rule_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "value":
			out.Values[i] = ec._Rule_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Rule_id(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Rule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Rule",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Rule_name(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Rule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Rule",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Rule_type(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Rule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Rule",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.MarkupRuleType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Rule_value(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Rule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Rule",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalFloat(res)
}

var searchImplementors = []string{"Search"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Search(ctx context.Context, sel ast.SelectionSet, obj *Search) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, searchImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Search")
		case "hotel":
			out.Values[i] = ec._Search_hotel(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Search_hotel(ctx context.Context, field graphql.CollectedField, obj *Search) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Search_hotel_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Search",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hotel, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*HotelSearch)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._HotelSearch(ctx, field.Selections, res)
}

var serviceStatusImplementors = []string{"ServiceStatus"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceStatus(ctx context.Context, sel ast.SelectionSet, obj *ServiceStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceStatusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceStatus")
		case "code":
			out.Values[i] = ec._ServiceStatus_code(ctx, field, obj)
		case "type":
			out.Values[i] = ec._ServiceStatus_type(ctx, field, obj)
		case "description":
			out.Values[i] = ec._ServiceStatus_description(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _ServiceStatus_code(ctx context.Context, field graphql.CollectedField, obj *ServiceStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceStatus_type(ctx context.Context, field graphql.CollectedField, obj *ServiceStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _ServiceStatus_description(ctx context.Context, field graphql.CollectedField, obj *ServiceStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "ServiceStatus",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var statImplementors = []string{"Stat"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Stat(ctx context.Context, sel ast.SelectionSet, obj *Stat) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, statImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Stat")
		case "start":
			out.Values[i] = ec._Stat_start(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "end":
			out.Values[i] = ec._Stat_end(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "duration":
			out.Values[i] = ec._Stat_duration(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Stat_start(ctx context.Context, field graphql.CollectedField, obj *Stat) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Stat",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Start, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Stat_end(ctx context.Context, field graphql.CollectedField, obj *Stat) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Stat",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.End, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Stat_duration(ctx context.Context, field graphql.CollectedField, obj *Stat) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Stat",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalFloat(*res)
}

var statAccessImplementors = []string{"StatAccess"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _StatAccess(ctx context.Context, sel ast.SelectionSet, obj *StatAccess) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, statAccessImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StatAccess")
		case "name":
			out.Values[i] = ec._StatAccess_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "total":
			out.Values[i] = ec._StatAccess_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "staticConfiguration":
			out.Values[i] = ec._StatAccess_staticConfiguration(ctx, field, obj)
		case "hotels":
			out.Values[i] = ec._StatAccess_hotels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "zones":
			out.Values[i] = ec._StatAccess_zones(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "cities":
			out.Values[i] = ec._StatAccess_cities(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "requestAccess":
			out.Values[i] = ec._StatAccess_requestAccess(ctx, field, obj)
		case "responseAccess":
			out.Values[i] = ec._StatAccess_responseAccess(ctx, field, obj)
		case "transactions":
			out.Values[i] = ec._StatAccess_transactions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "plugins":
			out.Values[i] = ec._StatAccess_plugins(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _StatAccess_name(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatAccess",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _StatAccess_total(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatAccess",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Stat(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _StatAccess_staticConfiguration(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatAccess",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StaticConfiguration, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Stat(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _StatAccess_hotels(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatAccess",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hotels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _StatAccess_zones(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatAccess",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Zones, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _StatAccess_cities(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatAccess",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cities, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _StatAccess_requestAccess(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatAccess",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestAccess, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*StatPlugin)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._StatPlugin(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _StatAccess_responseAccess(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatAccess",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseAccess, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*StatPlugin)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._StatPlugin(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _StatAccess_transactions(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatAccess",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Transactions, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]StatTransaction)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._StatTransaction(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _StatAccess_plugins(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatAccess",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plugins, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]StatPlugin)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._StatPlugin(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var statPluginImplementors = []string{"StatPlugin"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _StatPlugin(ctx context.Context, sel ast.SelectionSet, obj *StatPlugin) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, statPluginImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StatPlugin")
		case "name":
			out.Values[i] = ec._StatPlugin_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "total":
			out.Values[i] = ec._StatPlugin_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _StatPlugin_name(ctx context.Context, field graphql.CollectedField, obj *StatPlugin) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatPlugin",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _StatPlugin_total(ctx context.Context, field graphql.CollectedField, obj *StatPlugin) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatPlugin",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Stat(ctx, field.Selections, &res)
}

var statTransactionImplementors = []string{"StatTransaction"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _StatTransaction(ctx context.Context, sel ast.SelectionSet, obj *StatTransaction) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, statTransactionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StatTransaction")
		case "reference":
			out.Values[i] = ec._StatTransaction_reference(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "total":
			out.Values[i] = ec._StatTransaction_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "buildRequest":
			out.Values[i] = ec._StatTransaction_buildRequest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "workerCommunication":
			out.Values[i] = ec._StatTransaction_workerCommunication(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "parseResponse":
			out.Values[i] = ec._StatTransaction_parseResponse(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _StatTransaction_reference(ctx context.Context, field graphql.CollectedField, obj *StatTransaction) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatTransaction",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reference, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _StatTransaction_total(ctx context.Context, field graphql.CollectedField, obj *StatTransaction) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatTransaction",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Stat(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _StatTransaction_buildRequest(ctx context.Context, field graphql.CollectedField, obj *StatTransaction) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatTransaction",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildRequest, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Stat(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _StatTransaction_workerCommunication(ctx context.Context, field graphql.CollectedField, obj *StatTransaction) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatTransaction",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkerCommunication, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Stat(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _StatTransaction_parseResponse(ctx context.Context, field graphql.CollectedField, obj *StatTransaction) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatTransaction",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParseResponse, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Stat(ctx, field.Selections, &res)
}

var statsRequestImplementors = []string{"StatsRequest"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _StatsRequest(ctx context.Context, sel ast.SelectionSet, obj *StatsRequest) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, statsRequestImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StatsRequest")
		case "total":
			out.Values[i] = ec._StatsRequest_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "validation":
			out.Values[i] = ec._StatsRequest_validation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "process":
			out.Values[i] = ec._StatsRequest_process(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "configuration":
			out.Values[i] = ec._StatsRequest_configuration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "request":
			out.Values[i] = ec._StatsRequest_request(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "response":
			out.Values[i] = ec._StatsRequest_response(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "requestPlugin":
			out.Values[i] = ec._StatsRequest_requestPlugin(ctx, field, obj)
		case "responsePlugin":
			out.Values[i] = ec._StatsRequest_responsePlugin(ctx, field, obj)
		case "hotels":
			out.Values[i] = ec._StatsRequest_hotels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "zones":
			out.Values[i] = ec._StatsRequest_zones(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "cities":
			out.Values[i] = ec._StatsRequest_cities(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "dockerID":
			out.Values[i] = ec._StatsRequest_dockerID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "Accesses":
			out.Values[i] = ec._StatsRequest_Accesses(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _StatsRequest_total(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatsRequest",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Stat(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _StatsRequest_validation(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatsRequest",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Validation, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Stat(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _StatsRequest_process(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatsRequest",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Process, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Stat(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _StatsRequest_configuration(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatsRequest",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Configuration, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Stat(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _StatsRequest_request(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatsRequest",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Request, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Stat(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _StatsRequest_response(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatsRequest",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Response, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Stat(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _StatsRequest_requestPlugin(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatsRequest",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestPlugin, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*StatPlugin)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._StatPlugin(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _StatsRequest_responsePlugin(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatsRequest",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponsePlugin, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*StatPlugin)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._StatPlugin(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _StatsRequest_hotels(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatsRequest",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hotels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _StatsRequest_zones(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatsRequest",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Zones, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _StatsRequest_cities(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatsRequest",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cities, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _StatsRequest_dockerID(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatsRequest",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DockerID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _StatsRequest_Accesses(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StatsRequest",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Accesses, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]StatAccess)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._StatAccess(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var supplementImplementors = []string{"Supplement"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Supplement(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, supplementImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Supplement")
		case "code":
			out.Values[i] = ec._Supplement_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._Supplement_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Supplement_description(ctx, field, obj)
		case "supplementType":
			out.Values[i] = ec._Supplement_supplementType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "chargeType":
			out.Values[i] = ec._Supplement_chargeType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mandatory":
			out.Values[i] = ec._Supplement_mandatory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "durationType":
			out.Values[i] = ec._Supplement_durationType(ctx, field, obj)
		case "quantity":
			out.Values[i] = ec._Supplement_quantity(ctx, field, obj)
		case "unit":
			out.Values[i] = ec._Supplement_unit(ctx, field, obj)
		case "effectiveDate":
			out.Values[i] = ec._Supplement_effectiveDate(ctx, field, obj)
		case "expireDate":
			out.Values[i] = ec._Supplement_expireDate(ctx, field, obj)
		case "resort":
			out.Values[i] = ec._Supplement_resort(ctx, field, obj)
		case "price":
			out.Values[i] = ec._Supplement_price(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Supplement_code(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Supplement",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Supplement_name(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Supplement",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Supplement_description(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Supplement",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Supplement_supplementType(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Supplement",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupplementType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.SupplementType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Supplement_chargeType(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Supplement",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChargeType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.ChargeType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Supplement_mandatory(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Supplement",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mandatory, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _Supplement_durationType(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Supplement",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DurationType, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*domainHotelCommon.DurationType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _Supplement_quantity(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Supplement",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Quantity, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Supplement_unit(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Supplement",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unit, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*domainHotelCommon.UnitTimeType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _Supplement_effectiveDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Supplement",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EffectiveDate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Supplement_expireDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Supplement",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpireDate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Supplement_resort(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Supplement",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resort, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*domainHotelCommon.Resort)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Resort(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Supplement_price(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Supplement",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*domainHotelCommon.Price)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Price(ctx, field.Selections, res)
}

var surchargeImplementors = []string{"Surcharge"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Surcharge(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Surcharge) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, surchargeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Surcharge")
		case "chargeType":
			out.Values[i] = ec._Surcharge_chargeType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mandatory":
			out.Values[i] = ec._Surcharge_mandatory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "price":
			out.Values[i] = ec._Surcharge_price(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._Surcharge_description(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Surcharge_chargeType(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Surcharge) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Surcharge",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChargeType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.ChargeType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Surcharge_mandatory(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Surcharge) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Surcharge",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mandatory, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _Surcharge_price(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Surcharge) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Surcharge",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.Price)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Price(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Surcharge_description(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Surcharge) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Surcharge",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var transactionsImplementors = []string{"Transactions"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Transactions(ctx context.Context, sel ast.SelectionSet, obj *common.Transactions) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, transactionsImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Transactions")
		case "request":
			out.Values[i] = ec._Transactions_request(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "response":
			out.Values[i] = ec._Transactions_response(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "timeStamp":
			out.Values[i] = ec._Transactions_timeStamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Transactions_request(ctx context.Context, field graphql.CollectedField, obj *common.Transactions) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Transactions",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Request, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Transactions_response(ctx context.Context, field graphql.CollectedField, obj *common.Transactions) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Transactions",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Response, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Transactions_timeStamp(ctx context.Context, field graphql.CollectedField, obj *common.Transactions) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Transactions",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeStamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var warningImplementors = []string{"Warning"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Warning(ctx context.Context, sel ast.SelectionSet, obj *common.AdviseMessage) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, warningImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Warning")
		case "code":
			out.Values[i] = ec._Warning_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec._Warning_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._Warning_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Warning_code(ctx context.Context, field graphql.CollectedField, obj *common.AdviseMessage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Warning",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Warning_type(ctx context.Context, field graphql.CollectedField, obj *common.AdviseMessage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Warning",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Warning_description(ctx context.Context, field graphql.CollectedField, obj *common.AdviseMessage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Warning",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var __DirectiveImplementors = []string{"__Directive"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __DirectiveImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var __EnumValueImplementors = []string{"__EnumValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __EnumValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __FieldImplementors = []string{"__Field"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __FieldImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __InputValueImplementors = []string{"__InputValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __InputValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __SchemaImplementors = []string{"__Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __SchemaImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Directive(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var __TypeImplementors = []string{"__Type"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __TypeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field___Type_fields_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Field(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field___Type_enumValues_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___EnumValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) _BookableOptionSearch(ctx context.Context, sel ast.SelectionSet, obj *BookableOptionSearch) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case *domainHotelCommon.Option:
		return ec._HotelOptionSearch(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Priceable(ctx context.Context, sel ast.SelectionSet, obj *Priceable) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case domainHotelCommon.Markup:
		return ec._Markup(ctx, sel, &obj)
	case *domainHotelCommon.Markup:
		return ec._Markup(ctx, sel, obj)
	case domainHotelCommon.Price:
		return ec._Price(ctx, sel, &obj)
	case *domainHotelCommon.Price:
		return ec._Price(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Response(ctx context.Context, sel ast.SelectionSet, obj *Response) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case HotelSearch:
		return ec._HotelSearch(ctx, sel, &obj)
	case *HotelSearch:
		return ec._HotelSearch(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func UnmarshalAccessFilterInput(v interface{}) (search.TypeFilter, error) {
	var it search.TypeFilter
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "includes":
			var err error
			var ptr1 []string
			if v != nil {
				var rawIf2 []interface{}
				if v != nil {
					if tmp1, ok := v.([]interface{}); ok {
						rawIf2 = tmp1
					} else {
						rawIf2 = []interface{}{v}
					}
				}
				ptr1 = make([]string, len(rawIf2))
				for idx2 := range rawIf2 {
					ptr1[idx2], err = graphql.UnmarshalID(rawIf2[idx2])
				}
				it.Includes = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "excludes":
			var err error
			var ptr1 []string
			if v != nil {
				var rawIf2 []interface{}
				if v != nil {
					if tmp1, ok := v.([]interface{}); ok {
						rawIf2 = tmp1
					} else {
						rawIf2 = []interface{}{v}
					}
				}
				ptr1 = make([]string, len(rawIf2))
				for idx2 := range rawIf2 {
					ptr1[idx2], err = graphql.UnmarshalID(rawIf2[idx2])
				}
				it.Excludes = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalBusinessRulesInput(v interface{}) (domainHotelCommon.BusinessRules, error) {
	var it domainHotelCommon.BusinessRules
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "optionsQuota":
			var err error
			var ptr1 int
			if v != nil {
				ptr1, err = graphql.UnmarshalInt(v)
				it.OptionsQuota = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "businessRulesType":
			var err error
			var ptr1 domainHotelCommon.BusinessRulesType
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.BusinessRulesType = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalConfigurationInput(v interface{}) (access.AccessConfiguration, error) {
	var it access.AccessConfiguration
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "username":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Username = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "password":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Password = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "urls":
			var err error
			it.Urls, err = UnmarshalUrlsInput(v)
			if err != nil {
				return it, err
			}
		case "parameters":
			var err error
			var ptr1 []access.Parameter
			if v != nil {
				var rawIf2 []interface{}
				if v != nil {
					if tmp1, ok := v.([]interface{}); ok {
						rawIf2 = tmp1
					} else {
						rawIf2 = []interface{}{v}
					}
				}
				ptr1 = make([]access.Parameter, len(rawIf2))
				for idx2 := range rawIf2 {
					ptr1[idx2], err = UnmarshalParameterInput(rawIf2[idx2])
				}
				it.Parameters = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "markets":
			var err error
			var ptr1 []string
			if v != nil {
				var rawIf2 []interface{}
				if v != nil {
					if tmp1, ok := v.([]interface{}); ok {
						rawIf2 = tmp1
					} else {
						rawIf2 = []interface{}{v}
					}
				}
				ptr1 = make([]string, len(rawIf2))
				for idx2 := range rawIf2 {
					ptr1[idx2], err = graphql.UnmarshalString(rawIf2[idx2])
				}
				it.Markets = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "rateRules":
			var err error
			var ptr1 []access.RateRulesType
			if v != nil {
				var rawIf2 []interface{}
				if v != nil {
					if tmp1, ok := v.([]interface{}); ok {
						rawIf2 = tmp1
					} else {
						rawIf2 = []interface{}{v}
					}
				}
				ptr1 = make([]access.RateRulesType, len(rawIf2))
				for idx2 := range rawIf2 {
					err = (&ptr1[idx2]).UnmarshalGQL(rawIf2[idx2])
				}
				it.RateRules = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalFilterInput(v interface{}) (search.Filter, error) {
	var it search.Filter
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "access":
			var err error
			var ptr1 search.TypeFilter
			if v != nil {
				ptr1, err = UnmarshalAccessFilterInput(v)
				it.Access = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "rateRules":
			var err error
			var ptr1 search.RateRuleFilter
			if v != nil {
				ptr1, err = UnmarshalRateRulesFilterInput(v)
				it.RateRules = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalHotelCriteriaSearchInput(v interface{}) (HotelCriteriaSearchInput, error) {
	var it HotelCriteriaSearchInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "checkIn":
			var err error
			it.CheckIn, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "checkOut":
			var err error
			it.CheckOut, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "hotels":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Hotels = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Hotels[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "destinations":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Destinations = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Destinations[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "occupancies":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Occupancies = make([]domainHotelCommon.Occupancy, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Occupancies[idx1], err = UnmarshalRoomInput(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "language":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Language = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "currency":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Currency = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "nationality":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Nationality = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "market":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Market = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalHotelSettingsInput(v interface{}) (domainHotelCommon.Settings, error) {
	var it domainHotelCommon.Settings
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "context":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Context = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "useContext":
			var err error
			var ptr1 bool
			if v != nil {
				ptr1, err = graphql.UnmarshalBoolean(v)
				it.UseContext = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "connectUser":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.ConnectUser = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "client":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalID(v)
				it.Client = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "group":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalID(v)
				it.Group = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "timeout":
			var err error
			var ptr1 int
			if v != nil {
				ptr1, err = graphql.UnmarshalInt(v)
				it.Timeout = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "auditTransactions":
			var err error
			var ptr1 bool
			if v != nil {
				ptr1, err = graphql.UnmarshalBoolean(v)
				it.AuditTransactions = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "businessRules":
			var err error
			var ptr1 domainHotelCommon.BusinessRules
			if v != nil {
				ptr1, err = UnmarshalBusinessRulesInput(v)
				it.BusinessRules = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "suppliers":
			var err error
			var ptr1 []domainHotelCommon.Supplier
			if v != nil {
				var rawIf2 []interface{}
				if v != nil {
					if tmp1, ok := v.([]interface{}); ok {
						rawIf2 = tmp1
					} else {
						rawIf2 = []interface{}{v}
					}
				}
				ptr1 = make([]domainHotelCommon.Supplier, len(rawIf2))
				for idx2 := range rawIf2 {
					ptr1[idx2], err = UnmarshalHotelXSupplierInput(rawIf2[idx2])
				}
				it.Suppliers = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "plugins":
			var err error
			var ptr1 []domainHotelCommon.PluginStep
			if v != nil {
				var rawIf2 []interface{}
				if v != nil {
					if tmp1, ok := v.([]interface{}); ok {
						rawIf2 = tmp1
					} else {
						rawIf2 = []interface{}{v}
					}
				}
				ptr1 = make([]domainHotelCommon.PluginStep, len(rawIf2))
				for idx2 := range rawIf2 {
					ptr1[idx2], err = UnmarshalPluginStepInput(rawIf2[idx2])
				}
				it.Plugins = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "testMode":
			var err error
			var ptr1 bool
			if v != nil {
				ptr1, err = graphql.UnmarshalBoolean(v)
				it.TestMode = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "clientTokens":
			var err error
			var ptr1 []string
			if v != nil {
				var rawIf2 []interface{}
				if v != nil {
					if tmp1, ok := v.([]interface{}); ok {
						rawIf2 = tmp1
					} else {
						rawIf2 = []interface{}{v}
					}
				}
				ptr1 = make([]string, len(rawIf2))
				for idx2 := range rawIf2 {
					ptr1[idx2], err = graphql.UnmarshalString(rawIf2[idx2])
				}
				it.ClientTokens = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalHotelXAccessInput(v interface{}) (domainHotelCommon.Access, error) {
	var it domainHotelCommon.Access
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "accessId":
			var err error
			it.AccessId, err = graphql.UnmarshalID(v)
			if err != nil {
				return it, err
			}
		case "configuration":
			var err error
			var ptr1 access.AccessConfiguration
			if v != nil {
				ptr1, err = UnmarshalConfigurationInput(v)
				it.Configuration = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "settings":
			var err error
			var ptr1 domainHotelCommon.SettingsBase
			if v != nil {
				ptr1, err = UnmarshalSettingsBaseInput(v)
				it.Settings = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalHotelXFilterPluginTypeInput(v interface{}) (domainHotelCommon.FilterPlugin, error) {
	var it domainHotelCommon.FilterPlugin
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "step":
			var err error
			err = (&it.Step).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			var castTmp string
			castTmp, err = graphql.UnmarshalString(v)
			it.Type = domainHotelCommon.PluginType(castTmp)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalHotelXFilterSearchInput(v interface{}) (search.FilterSearch, error) {
	var it search.FilterSearch
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "access":
			var err error
			var ptr1 search.TypeFilter
			if v != nil {
				ptr1, err = UnmarshalAccessFilterInput(v)
				it.Access = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "rateRules":
			var err error
			var ptr1 search.RateRuleFilter
			if v != nil {
				ptr1, err = UnmarshalRateRulesFilterInput(v)
				it.RateRules = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "plugin":
			var err error
			var ptr1 domainHotelCommon.FilterPluginType
			if v != nil {
				ptr1, err = UnmarshalHotelXPluginFilterInput(v)
				it.Plugin = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalHotelXPluginFilterInput(v interface{}) (domainHotelCommon.FilterPluginType, error) {
	var it domainHotelCommon.FilterPluginType
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "includes":
			var err error
			var ptr1 []domainHotelCommon.FilterPlugin
			if v != nil {
				var rawIf2 []interface{}
				if v != nil {
					if tmp1, ok := v.([]interface{}); ok {
						rawIf2 = tmp1
					} else {
						rawIf2 = []interface{}{v}
					}
				}
				ptr1 = make([]domainHotelCommon.FilterPlugin, len(rawIf2))
				for idx2 := range rawIf2 {
					ptr1[idx2], err = UnmarshalHotelXFilterPluginTypeInput(rawIf2[idx2])
				}
				it.Includes = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "excludes":
			var err error
			var ptr1 []domainHotelCommon.FilterPlugin
			if v != nil {
				var rawIf2 []interface{}
				if v != nil {
					if tmp1, ok := v.([]interface{}); ok {
						rawIf2 = tmp1
					} else {
						rawIf2 = []interface{}{v}
					}
				}
				ptr1 = make([]domainHotelCommon.FilterPlugin, len(rawIf2))
				for idx2 := range rawIf2 {
					ptr1[idx2], err = UnmarshalHotelXFilterPluginTypeInput(rawIf2[idx2])
				}
				it.Excludes = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalHotelXSupplierInput(v interface{}) (domainHotelCommon.Supplier, error) {
	var it domainHotelCommon.Supplier
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "settings":
			var err error
			var ptr1 domainHotelCommon.SettingsBase
			if v != nil {
				ptr1, err = UnmarshalSettingsBaseInput(v)
				it.Settings = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "code":
			var err error
			it.Code, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "accesses":
			var err error
			var ptr1 []domainHotelCommon.Access
			if v != nil {
				var rawIf2 []interface{}
				if v != nil {
					if tmp1, ok := v.([]interface{}); ok {
						rawIf2 = tmp1
					} else {
						rawIf2 = []interface{}{v}
					}
				}
				ptr1 = make([]domainHotelCommon.Access, len(rawIf2))
				for idx2 := range rawIf2 {
					ptr1[idx2], err = UnmarshalHotelXAccessInput(rawIf2[idx2])
				}
				it.Accesses = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalParameterInput(v interface{}) (access.Parameter, error) {
	var it access.Parameter
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "key":
			var err error
			it.Key, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error
			it.Value, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalPaxInput(v interface{}) (domainHotelCommon.Pax, error) {
	var it domainHotelCommon.Pax
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "age":
			var err error
			it.Age, err = graphql.UnmarshalInt(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalPluginStepInput(v interface{}) (domainHotelCommon.PluginStep, error) {
	var it domainHotelCommon.PluginStep
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "step":
			var err error
			err = (&it.Step).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "pluginsType":
			var err error
			var ptr1 []domainHotelCommon.Plugin
			if v != nil {
				var rawIf2 []interface{}
				if v != nil {
					if tmp1, ok := v.([]interface{}); ok {
						rawIf2 = tmp1
					} else {
						rawIf2 = []interface{}{v}
					}
				}
				ptr1 = make([]domainHotelCommon.Plugin, len(rawIf2))
				for idx2 := range rawIf2 {
					ptr1[idx2], err = UnmarshalPluginsInput(rawIf2[idx2])
				}
				it.PluginsType = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalPluginsInput(v interface{}) (domainHotelCommon.Plugin, error) {
	var it domainHotelCommon.Plugin
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "type":
			var err error
			err = (&it.Type).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "parameters":
			var err error
			var ptr1 []access.Parameter
			if v != nil {
				var rawIf2 []interface{}
				if v != nil {
					if tmp1, ok := v.([]interface{}); ok {
						rawIf2 = tmp1
					} else {
						rawIf2 = []interface{}{v}
					}
				}
				ptr1 = make([]access.Parameter, len(rawIf2))
				for idx2 := range rawIf2 {
					ptr1[idx2], err = UnmarshalParameterInput(rawIf2[idx2])
				}
				it.Parameters = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalRateRulesFilterInput(v interface{}) (search.RateRuleFilter, error) {
	var it search.RateRuleFilter
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "includes":
			var err error
			var ptr1 []access.RateRulesType
			if v != nil {
				var rawIf2 []interface{}
				if v != nil {
					if tmp1, ok := v.([]interface{}); ok {
						rawIf2 = tmp1
					} else {
						rawIf2 = []interface{}{v}
					}
				}
				ptr1 = make([]access.RateRulesType, len(rawIf2))
				for idx2 := range rawIf2 {
					err = (&ptr1[idx2]).UnmarshalGQL(rawIf2[idx2])
				}
				it.Includes = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "excludes":
			var err error
			var ptr1 []access.RateRulesType
			if v != nil {
				var rawIf2 []interface{}
				if v != nil {
					if tmp1, ok := v.([]interface{}); ok {
						rawIf2 = tmp1
					} else {
						rawIf2 = []interface{}{v}
					}
				}
				ptr1 = make([]access.RateRulesType, len(rawIf2))
				for idx2 := range rawIf2 {
					err = (&ptr1[idx2]).UnmarshalGQL(rawIf2[idx2])
				}
				it.Excludes = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalRoomInput(v interface{}) (domainHotelCommon.Occupancy, error) {
	var it domainHotelCommon.Occupancy
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "paxes":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Paxes = make([]domainHotelCommon.Pax, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Paxes[idx1], err = UnmarshalPaxInput(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalSettingsBaseInput(v interface{}) (domainHotelCommon.SettingsBase, error) {
	var it domainHotelCommon.SettingsBase
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "timeout":
			var err error
			var ptr1 int
			if v != nil {
				ptr1, err = graphql.UnmarshalInt(v)
				it.Timeout = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "auditTransactions":
			var err error
			var ptr1 bool
			if v != nil {
				ptr1, err = graphql.UnmarshalBoolean(v)
				it.AuditTransactions = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "businessRules":
			var err error
			var ptr1 domainHotelCommon.BusinessRules
			if v != nil {
				ptr1, err = UnmarshalBusinessRulesInput(v)
				it.BusinessRules = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "currency":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Currency = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalUrlsInput(v interface{}) (access.Urls, error) {
	var it access.Urls
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "search":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Search = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "quote":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Quote = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "book":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Book = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "generic":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Generic = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) FieldMiddleware(ctx context.Context, obj interface{}, next graphql.Resolver) (ret interface{}) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	res, err := ec.ResolverMiddleware(ctx, next)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return res
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "schema.graphql", Input: `schema {
  query: Query
}

type Query{
  hotelX: HotelXQuery
}

type HotelXQuery{
  # Available options of an hotel for a given date and itinerary. It does not filter different classes, times or
  # fares. It will always retrieve all results returned by the suppliers. The availability request is very straight
  # forward. It only requires the criteria of search (destination, travel dates and the number of pax in each room).
  # But you must preload the other fields in our system by complete the fields absents.
  search: HotelSearch

  # Returns status of the search service.
  searchStatusService: ServiceStatus!
}

# Available options for a given date and itinerary. It does not filter different classes, times or
# fares. It will always retrieve all results returned by the suppliers. The availability request is very straight
# forward.
type Search {
  # Available options of an hotel for a given date and itinerary. It does not filter different classes, times or
  # fares. It will always retrieve all results returned by the suppliers. The availability request is very straight
  # forward. It only requires the criteria of search (destination, travel dates and the number of pax in each room).
  # But you must preload the other fields in our system by complete the fields absents.
  hotel(token: String, criteria: HotelCriteriaSearchInput, settings: HotelSettingsInput, filter: FilterInput): HotelSearch @deprecated(reason: "deprecated from 2017-11-21. You can find it in query at HotelX")
}

# Business rules type
enum BusinessRulesType {
  # The cheapest options is returned without exceeding the optionsQuota limit.
  CHEAPER_AMOUNT
  
  # Groups the option by room type without exceeding the optionsQuota limit.
  ROOM_TYPE
}

# Options type
enum CancelPenaltyType {
  # Indicates the number of nights to be penalized.
  NIGHTS
  
  # Indicates the percentage to pay based on the option price.
  PERCENT
  
  # Indicates the exact amount payable.
  IMPORT
}

# Charge Type
enum ChargeType {
  # The charge is included.
  INCLUDE
  
  # The charge is excluded.
  EXCLUDE
}

# Duration Type
enum DurationType {
  # Date range is set.
  RANGE
  
  # Not restricted by date.
  OPEN
}

# Indicates what type of value is the markup, by percentage or is an import.
enum MarkupRuleType {
  # Indicates the percentage applied by a rule.
  PERCENT
  
  # Indicates the exact amount applied by a rule.
  IMPORT
}

# Plugin Step Type. https://docs.travelgatex.com/hotelx/plugins/overview/
enum PluginStepType {
  # Plugins executed after Buyer requests message to HotelX
  REQUEST
  
  # Plugins executed before sending request to Supplier using Access and after Accesses have been calculated
  REQUEST_ACCESS
  
  # Plugins executed after Supplier responds message. For every option returned
  RESPONSE_OPTION
  
  # Plugins executed after all Access options has been responded
  RESPONSE_ACCESS
  
  # Plugins executed before HotelX responds message to to Buyer
  RESPONSE
}

# Plugin Type. https://docs.travelgatex.com/hotelx/plugins/overview/
enum PluginType {
  # PRE_STEP is the first plugin that a step will execute, allows a full range of operations:
  # split arrays, join arrays, modify object values, add or remove object instances
  PRE_STEP
  
  # HOTEL_MAP allows to match Seller and Buyer hotel codes based on contexts
  HOTEL_MAP
  
  # BOARD_MAP allows to match Seller and Buyer board codes based on contexts
  BOARD_MAP
  
  # ROOM_MAP allows to match Seller and Buyer room codes based on contexts
  ROOM_MAP
  
  # CURRENCY_CONVERSION allows to match Seller and Buyer hotel codes based on contexts
  CURRENCY_CONVERSION
  
  # MARKUP allows to apply markup over price
  MARKUP
  
  # AGGREGATION allows to aggregate multiple supplier options
  AGGREGATION
  
  # POST_STEP is the last plugin that a step will execute, allows a full range of operations:
  # split arrays, join arrays, modify object values, add or remove object instances
  POST_STEP
}

# Price Type
enum PriceType {
  # Price without deductions.
  GROSS
  
  # Price after deducting all discounts and rebates.
  NET
  
  # Final quantity. Sum of multiple quantities.
  AMOUNT
}

# Service Type
enum ServiceType {
  # A ticket or pass authorizing the holder to ski in a certain place or resort. Gross.
  SKI_PASS
}

# Indicartes options status
enum StatusType {
  # The status of the avail is available
  OK
  
  # The status of the avail is On request
  RQ
}

# Supplement Type
enum SupplementType {
  # A ticket or pass authorizing the holder to ski in a certain place or resort.
  SKI_PASS
  
  # Lessons of any type that the costumer can take.
  LESSONS
  
  # Supplement of a determined meal plan.
  MEALS
  
  # Extra equipment for a specific purpose.
  EQUIPMENT
  
  # Admission to some service.
  TICKET
  
  # Transfers used by the costumer.
  TRANSFERS
  
  # Gala: A festive occasion, celebration or special entertainment.
  GALA
  
  # Activities that the costumer can do.
  ACTIVITY
}

# Unit Time Type
enum UnitTimeType {
  # Day
  DAY
  
  # Hour
  HOUR
}

# Options payment type
enum PaymentType {
  # The payment is managed by the supplier.
  MERCHANT
  
  # The payment is made straight to the actual payee, without sending it through an intermediary or a third party.
  DIRECT
  
  # The payment is managed by the supplier. The payment is effectuated at the time of booking.
  CARD_BOOKING
  
  # The payment is managed by the supplier. The payment is effectuated at check in in the hotel.
  CARD_CHECK_IN
}

# Rate Rules
enum RateRulesType {
  # The product can't be sold separately from another product attached to it, such as a flight.
  PACKAGE
  
  # Options that can only be sold to people who are 55 and older.
  OLDER55
  
  # Options that can only be sold to people who are 60 and older.
  OLDER60
  
  # Options that can only be sold to people who are 65 and older.
  OLDER65
  
  # The rate CanaryResident is applicable to Canary Islands residents only.
  CANARY_RESIDENT
  
  # The rate BalearicResident is applicable to Balearic Islands residents only.
  BALEARIC_RESIDENT
  
  # The rate largeFamily is applied to large families and is determined by each supplier
  LARGE_FAMILY
  
  # The rate honeymoon is applied to those who just got married and is determined by each supplier.
  HONEYMOON
  
  # The rate publicServant is applicable to public servants only.
  PUBLIC_SERVANT
  
  # The rate unemployed is applied to those without work.
  UNEMPLOYED

  #The rate normal refers to options without RateRule
  NORMAL

  #The rate non refundable is applied to non refundable options
  NON_REFUNDABLE
}

# Include *OR* exclude accesses in this specific search query. If not specified, default accesses will be used.
# Only one list (includes or excludes) *MUST* be used.
input AccessFilterInput {
  # These Access IDs will overwrite the default configuration. Only the IDs on this list will be used in the search query.
  includes: [ID!]
  
  # These Access IDs will overwrite the default configuration. The IDs on this list will be excluded from the search query.
  excludes: [ID!]
}

# List of business rules to use as filter on the options.
input BusinessRulesInput {
  # Options quota per search. Maximum numbers of options to be returned by the search query.
  optionsQuota: Int
  
  # Different business rules to filter the returned options.
  businessRulesType: BusinessRulesType
}

# The information and credentials required to access the supplier’s system.
input ConfigurationInput {
  # User name for the connection.
  username: String
  
  # Password for the connection
  password: String
  
  # URL or endpoint for the connection.
  urls:           UrlsInput!
  
  # List of parameters with additional required information.
  parameters: [ParameterInput!]
  
  # Source Markets allowed for the Access
  markets: [String!]
  
  # RateRules allowed for the access.
  rateRules: [RateRulesType!]
}

input HotelXFilterSearchInput{
  # Filter that selects the filter criteria which will be used in this availability. Currently you can only choose the accesses.
  # You must choose one of them, include or exclude, or the other alternative isn't specified anything.
  # If input both, you will receive a validation error that indicates this error.

  # You can specify one of the filters or any of them. In this latter case, all the configurated accesses will be executed.
  access: AccessFilterInput

  # If requested, only options with the specified rateRules will be returned
  rateRules: RateRulesFilterInput

  # Only is possible to specify one of this filters, it allows to filter which plugins have to be executed or excluded
  plugin: HotelXPluginFilterInput
}
# Filter that selects the filter criteria which will be used in this availability. Currently you can only choose the accesses.
# You must choose one of them, include or exclude, or the other alternative isn't specified anything.
# If input both, you will receive a validation error that indicates this error.
#@deprecated(reason: "deprecated from 2018-08-20. Please, use filterSearch")
input FilterInput {
  # You can specify one of the filters or any of them. In this latter case, all the configurated accesses will be executed.
  access: AccessFilterInput

  # If requested, only options with the specified rateRules will be returned
  rateRules: RateRulesFilterInput
}

# Search criteria contains destination, travel dates and the number of pax in each room.
# You must preload the other fields in our system by complete the fields absents.
input HotelCriteriaSearchInput {
  # Check-in date for booking
  # Format: YYYY-MM-DD
  checkIn: Date!
  
  # Check-out, booking date
  # Format: YYYY-MM-DD
  checkOut: Date!
  
  # Hotel Codes.
  hotels: [String!]

  # Destination codes.
  destinations: [String!]
  
  # For multi-room bookings, this array will contain multiple elements (rooms).
  # For each room you have to specify its own occupancy.
  occupancies: [RoomInput!]!
  
  # Language to be used in request
  language : Language
  
  # Currency requested if supported by supplier
  currency : Currency
  
  # Nationality of the guest (use ISO3166_1_alfa_2)
  nationality : Country
  
  # Targeted zone, country or point-ofsale-to be used in request.
  market : String
}

# Settings that you can edit for this avail. Values are loaded by default in our Back Office.
input HotelSettingsInput {
  # Indicates the context of the I/O codes (hotel, board, room and rates)
  context: String
  
  #Indicates if you want use context, or not, by default is true.
  #@deprecated(reason: "deprecated from 2017-12-12. Redundant.")
  useContext: Boolean
  
  # This field is occurs only if the authorization header is of the type JWT.. It is used to change the user that has been set by default in the preload.
  #@deprecated(reason: "deprecated from 2018-03-19. Redundant.")
  connectUser: String
  
  # Client name, this field is occurs only if the authorization header is of the type JWT.. It is used to change the user that has been set by default in the preload.
  client: ID
  
  # Group whose resources want to be used
  group: ID
  
  # Milliseconds before the connection is closed.
  timeout: Int
  
  # Returns all the transactions exchanged with the supplier.
  auditTransactions: Boolean
  
  # Business rules
  businessRules: BusinessRulesInput
  
  # Array of suppliers. Each one contains its own code, settings and accesses.
  suppliers: [HotelXSupplierInput!]
  
  # Array of plugins to execute.
  plugins: [PluginStepInput!]

  # This flag allows only the accesses checked as test. By default is production.
  testMode: Boolean

  # Used to identify the origin of the request, this is only used in plugins. 
  clientTokens: [String!] 
}

# AccessInput overwrites an existent access in our Back Office or creates a new
# one to be used in this search query only. An access object contains its own code, configuration and settings.
input HotelXAccessInput {
  # The accessID used to identify the existing access in our Back Office in order to
  # overwrite it. Acts as an identifier in this search. It can either exist or not.
  accessId: ID!
  
  # Information required to access the supplier's system.
  configuration: ConfigurationInput
  
  # You can configure an special settings for any access. This level overwrites the search and supplier settings levels.
  settings: SettingsBaseInput
}

# Supplier object. Contains its own settings, code and access.
input HotelXSupplierInput {
  # You can configure an special settings for any supplier. This level overwrites the avail settings level but not the
  # access settings level.
  settings: SettingsBaseInput
  
  # Code that represents a supplier in our system.
  # This information is mandatory.
  code: String!
  
  # Array of accesses that can overwrite an existing access information or include a new access for this avail.
  accesses: [HotelXAccessInput!]
}

# Pax object that contains the pax age.
input PaxInput {
  # Pax age.
  age: Int!
}

# If requested, only options with the specified rateRules will be returned
input RateRulesFilterInput {
  # if includes not nil: only options without rate rules and options with rate rules found in includes will be returned
  includes: [RateRulesType!]
  
  # if excludes not nil: only options without rate rules and options with rate rules that haven't been sent in excludes will be returned
  excludes: [RateRulesType!]
}

# Occupancy for a room. It contains a list of pax ages.
input RoomInput {
  # Array of pax ages. The number of items in the array will indicate the pax occupancy.
  paxes: [PaxInput!]!
}

# Plugin to execute.
input PluginsInput {
  # type of the plugins to execute
  type: PluginType!
  
  # name of plugin to execute
  name: String!
  
  # Plugin's parameters
  parameters: [ParameterInput!]
}

# Plugin to execute.
input PluginStepInput {
  # Indicates where the plugin will be executed.
  step: PluginStepType!
  
  # Indicates the plugin that will be executed.
  pluginsType: [PluginsInput!]
}

# Contains the time out and business rules of a supplier or an access.
input SettingsBaseInput {
  # Milliseconds before the connection is closed.
  timeout: Int
  
  # Specifies if transactions exchanged with the supplier have to be logged or not.
  auditTransactions: Boolean
  
  # Business rules
  businessRules: BusinessRulesInput

  # The currency
  currency: Currency
}

input HotelXPluginFilterInput{
  # Plugins to include (only these plugins will be executed)
  includes: [HotelXFilterPluginTypeInput!]
  # Plugins to exclude
  excludes: [HotelXFilterPluginTypeInput!]
}
input HotelXFilterPluginTypeInput{
  # The Step of the plugin to filter
  step: PluginStepType!
  # The Type of the plugin to filter
  type: String!
  # The Name of the plugin to filter
  name: String!
}
# Parameters Input.
input ParameterInput {  
  # Contains the keyword/Id to identify a parameter.
  # This information is mandatory.
  key: String!
  # Contains the parameter values.
  # This information is mandatory.
  value: String!
}

# URLs Input
input UrlsInput {
  # Specific URL for Availability method.
  search:         URI
  # Specific URL for Reservation method.
  quote:          URI
  # Specific URL for Valuation method.
  book:           URI
  # Supplier URL used for multiple methods.
  generic:        URI
}

interface BookableOptionSearch {
  # Supplier that offers this option.
  supplierCode: String!
  
  # Access code of this option.
  accessCode: String!
  
  # Indicates the id to be used on Quote as key
  id: String!
}

interface Priceable {
  # Specifies the currency.
  currency: Currency!
  
  # Is binding.
  binding: Boolean!
  
  # Specifies the import net.
  net: Float!
  
  # Specifies the import gross.
  gross: Float
  
  # Specifies the exchange.
  exchange: Exchange!
}

interface Response {
  # Application stats
  stats(token: String!): StatsRequest
  
  # Data sent and received in the supplier’s original format.
  auditData: AuditData
  
  # Errors that lead the service to stop
  errors: [Error!]
  
  # Potentially harmful situations or errors that do not stop the service
  warnings: [Warning!]
}

# Additional information about the option
type AddOns {
  # Extra information from the distribution layer
  distribute: JSON @deprecated(reason: "deprecated from 2018-05-21. You can find it in distribution AddOn")
  
  # Extra information from the distribution layer
  distribution: [AddOn!]
}

# Additional information about the option
type AddOn {
  # Contains keyword/ID to identify the AddOn.
  key: String!
  
  # Contains AddOn values.
  value: JSON!
}

# Data sent and received in the supplier’s native format.
type AuditData {
  # List of transactions data
  transactions:    [Transactions!]!
  
  # TimeStamp
  timeStamp:       DateTime!
  
  # Process time in milliseconds (ms)
  processTime:     Float!
}

# Contains information about a bed.
type Bed {
  # Specifies the bed type
  type: String
  
  # Description about the bed
  description: String
  
  # Indicates number of beds in a room
  count: Int
  
  # Specifies if the bed is shared or not
  shared: Boolean
}

# Contains information for cancellation penalities..
type CancelPenalty {
  # Cancellation fees applicable X number of hours before the check-in date
  hoursBefore: Int!
  
  # Type of penalty; this can be Nights, Percent or Import
  penaltyType: CancelPenaltyType!
  
  # Currency used in the cancellation policy
  currency: Currency!
  
  # Value of the cancellation policy
  value: Float!
}

# Information about a policy cancellation.
type CancelPolicy {
  # Indicates if the option is refundable or non-refundable
  refundable: Boolean!
  
  # List of cancellation penalties
  cancelPenalties: [CancelPenalty!]
}

# Search criteria contains destination, travel dates and the number of pax in each room.
type CriteriaSearch {
  # Check-in date for booking
  # Format: YYYY-MM-DD
  checkIn: Date!
  
  # Check-out, booking date
  # Format: YYYY-MM-DD
  checkOut: Date!
  
  # Contains the list of hotels's ID
  hotels: [String!]!
  
  # For multi-room bookings, this array will contain multiple elements (rooms).
  # For each room you have to specify its own occupancy.
  occupancies: [RoomCriteria!]!
  
  # Language to be used in request
  language : Language
  
  # Currency requested if supported by supplier
  currency : Currency
  
  # Nationality of the guest (use ISO3166_1_alfa_2)
  nationality : Country
  
  # Targeted zone, country or point-ofsale-to be used in request.
  market : String!
}

# Provides information about the currency of original, and its rate applied over the results returned by the Supplier.
type Exchange {
  # Provide information about the currency of origin
  currency: Currency!
  
  # Provides information about the rate applied over results
  rate: Float!
}

# An option includes hotel information, meal plan, total price, conditions and room description
type HotelOptionSearch implements BookableOptionSearch {
  # Supplier that offers this option.
  supplierCode: String!
  
  # Access code of this option.
  accessCode: String!
  
  # Market of this option.
  market: String!
  
  # Code of the hotel in the context selected.
  hotelCode: String!
  
  # Supplier's hotel code.
  hotelCodeSupplier: String!
  
  # Name of the hotel.
  hotelName: String
  
  # Code of the board in the context selected.
  boardCode: String!
  
  # Supplier's board code.
  boardCodeSupplier: String!
  
  # Indicates the payment type of the option returned. Possible options: Merchant, Direct, Card Booking, Card check in and Mixed.
  paymentType: PaymentType!
  
  # The possible values in status in response are Available (OK) or On Request (RQ).
  status: StatusType!
  
  # List of occupancies for the request
  occupancies: [Occupancy!]!
  
  # List of rooms of the option returned.
  rooms: [Room!]!
  
  # Specifies the prices (Gross, Net and Amount) of the option returned.
  price: Price!
  
  # List of supplements of the option returned.
  supplements: [Supplement]
  
  # List of surcharges of the option returned.
  surcharges: [Surcharge!]!
  
  # Specifies rate rules of the option returned.
  rateRules: [RateRulesType!]
  
  # Specifies cancel policies of the option returned.
  cancelPolicy: CancelPolicy
  
  # Additional information about the option.
  remarks: String
  
  # Additional information about the option
  addOns: AddOns
  
  # Token for Deep Link
  token: String!
  
  # Indicates the quote key
  id: String!
}

# Results from Avail Hotel; contains all the available options for a given date and itinerary
type HotelSearch implements Response {
  # Indicates the context of the response.
  context: String
  
  # Application stats in string format
  stats(token: String!): StatsRequest
  
  # Data sent and received in the supplier's native format.
  auditData: AuditData
  
  # Request Criteria
  requestCriteria: CriteriaSearch
  
  # List of options returned according to the request.
  options: [HotelOptionSearch]
  
  # Errors that abort services
  errors: [Error!]
  
  # Potentially harmful situations or errors that won't force the service to abort
  warnings: [Warning!]
}

# Informs markup applied over supplier price.
type Markup implements Priceable {
  #channel of markup application.
  channel: String
  
  # Currency code indicating which currency should be paid.
  # This information is mandatory.
  currency: Currency!
  
  # It indicates if the price indicated in the gross must be respected.
  # That is, the customer can not sell the room / option at a price lower than that established by the supplier.
  # This information is mandatory.
  binding: Boolean!
  
  # Indicates the net price that the customer must pay to the supplier plus the markup.
  # This information is mandatory.
  net: Float!
  
  # Indicates the retail price that the supplier sells to the customer plus the markup.
  gross: Float
  
  # Informs about the currency of origin, and the rate applied over result.
  # This information is mandatory.
  exchange: Exchange!
  
  # Breakdown of the applied rules for a markup
  rules: [Rule!]!
}

# Information about occupancy.
type Occupancy {
  # Unique ID room in this option.
  id: Int!
  
  # List of pax of this occupancy.
  paxes: [Pax!]!
}

# Specifies the age pax. The range of what is considered an adult, infant or baby is particular to each supplier.
type Pax {
  # Specifies the age pax.
  age: Int!
}

# Price indicates the value of the room/option.
# Supplements and/or surcharges can be included into the price, and will be verified with nodes Supplements/Surcharges.
type Price implements Priceable {
  # Currency code indicating which currency should be paid.
  # This information is mandatory.
  currency: Currency!
  
  # It indicates if the price indicated in the gross must be respected.
  # That is, the customer can not sell the room / option at a price lower than that established by the supplier.
  # This information is mandatory.
  binding: Boolean!
  
  # Indicates the net price that the customer must pay to the supplier.
  # This information is mandatory.
  net: Float!
  
  # Indicates the retail price that the supplier sells to the customer.
  gross: Float
  
  # Provides information about the currency of original, and its rate applied over the results returned by the Supplier.
  # This information is mandatory.
  exchange: Exchange!
  
  # Informs markup applied over supplier price.
  markups: [Markup!]
}

# Contains internal information.
type StatsRequest {
  # Total transaction time
  total:          Stat!
  
  # Request validation time
  validation:     Stat!
  
  # Process time. Contains communication time, parse time and plugin time.
  process:        Stat!
  
  # Build access time
  configuration:	Stat!
  
  # Request time
  request:				Stat!
  
  # Response time
  response:       Stat!
  
  # Plugin execution time
  requestPlugin:  StatPlugin
  
  # Plugin execution time
  responsePlugin: StatPlugin
  
  # Number of hotels
  hotels:         Int!
  
  # Number of zones
  zones:          Int!
  
  # Number of cities
  cities:         Int!
  
  # Docker Id
  dockerID:       String!
  
  # Detail access time
  Accesses:       [StatAccess!]!
}

# Information about daily price.
type PriceBreakdown {
  # Start date in which the price becomes effective.
  effectiveDate: Date!
  
  # Expire date of price.
  expireDate: Date!
  
  # Specifies the daily price.
  price: Price!
}

# Information about room promotions(offers).
type Promotion {
  # Specifies the promotion code.
  code: String!
  
  # Specifies the promotion name.
  name: String
  
  # Promotion effective date.
  effectiveDate: Date
  
  # Promotion expire date.
  expireDate: Date
}

# Information about the rate of the option returned.
type RatePlan {
  # Specifies the rate code.
  code: String!
  
  # Specifies the rate name.
  name: String
  
  # Start date in which the rate becomes effective.
  effectiveDate: Date
  
  # Expire date of the rate.
  expireDate: Date
}

# Contains information about the Resort.
type Resort {
  # Specifies the resort code.
  code: String!
  
  # Specifies the resort name.
  name: String
  
  # Specifies the resort description.
  description: String
}

# Contains the room information of the option returned.
type Room {
  # ID reference to the occupancy
  occupancyRefId: Int!
  
  # Indicates the room code
  code: String!
  
  # Description about the room
  description: String
  
  # Identifies if the room is refundable or not.
  refundable: Boolean
  
  # Number of rooms available with the same type.
  units: Int
  
  # Specifies the room price.
  roomPrice: RoomPrice!
  
  # List of beds.
  beds: [Bed!]
  
  # Daily break downs rate plan.
  ratePlans: [RatePlan!]
  
  # Daily break downs promotions.
  promotions: [Promotion!]
}

# Occupancy for a room. It contains a list of pax ages.
type RoomCriteria {
  # Array of pax ages. The number of items in the array will indicate the pax occupancy.
  paxes: [Pax!]!
}

# Specifies the room price.
type RoomPrice {
  # Total price for all days.
  price: Price!
  
  # Daily break downs price.
  breakdown: [PriceBreakdown!]
}

type Rule {
  # rule identifier
  id: String!
  
  # rule name
  name: String
  
  # type of the value
  type: MarkupRuleType!
  
  # value applied by this rule
  value: Float!
}

# Indicates the status of the service
type ServiceStatus{
  # Status code
  code: String
  
  # Status type
  type: String
  
  # Status description
  description : String
}

type Stat {
  # Start UTC
  start:      DateTime!
  
  # End UTC
  end:        DateTime!
  
  # Difference between start and end in miliseconds
  duration:   Float
}

type StatAccess {
  # Access name
  name:                   String!
  
  # Total access time
  total:                  Stat!
  
  # Static configuration time
  staticConfiguration:    Stat
  
  # Number of hotels
  hotels:                 Int!
  
  # Number of zones
  zones:                  Int!
  
  # Number of cities
  cities:                 Int!
  
  # Access request time
  requestAccess:          StatPlugin
  
  # Access response time
  responseAccess:         StatPlugin
  
  # Detail transaction time
  transactions:           [StatTransaction!]!
  
  # Plugin execution time
  plugins:                [StatPlugin!]
}

type StatTransaction {
  # Extra information about transaction.
  reference:              String!
  
  # Total transaction time
  total:                  Stat!
  
  # Build request time
  buildRequest:           Stat!
  
  # Worker connection time
  workerCommunication:    Stat!
  
  # Parse response time
  parseResponse:          Stat!
}

type StatPlugin{
  # Plugin name
  name:     String!
  
  # total plugin time
  total:    Stat!
}

# Supplement that it can be or its already added to the option returned. Contains all the information about the supplement.
type Supplement {
  # Specifies the supplement code.
  code: String!
  
  # Specifies the supplement name.
  name: String
  
  # Specifies the supplement description.
  description: String
  
  # Indicates the supplement type. Possible types: Fee, Ski_pass, Lessons, Meals, Equipment, Ticket, Transfers, Gla, Activity or Null.
  supplementType: SupplementType!
  
  # Indicates the charge types. We need to know whether the supplements have to be paid when the consumer gets to the hotel or beforehand.
  # Possible charge types: Include or Exclude.
  # when include: this supplement is mandatory and included in the option's price
  # when exclude: this supplement is not included in the option's price
  chargeType: ChargeType!
  
  # Indicates if the supplement is mandatory or not. If mandatory, this supplement will be applied to this option
  # if the chargeType is excluded the customer will have to pay it directly at the hotel
  mandatory: Boolean!
  
  # Specifies the duration type. Possible duration types: Range (specified dates) or Open. This field is mandatory for PDI.
  durationType: DurationType
  
  # Indicates the quantity of field in the element "unit".
  quantity: Int
  
  # Indicates the unit type. Possible unit types: Day or Hour.
  unit: UnitTimeType
  
  # Indicates the effective date of the supplement.
  effectiveDate: Date
  
  # Indicates the expire date of the supplement.
  expireDate: Date
  
  # Contains information about the resort
  resort: Resort
  
  # Indicates the supplement price.
  price: Price
}

# Surcharge that it can be or it is already added to the option returned. Contains all the information about the surcharge.
type Surcharge {
  # Indicates the charge types. We need to know whether the supplements have to be paid when the consumer gets to the hotel or beforehand.
  # Possible charge types: Include or Exclude.
  # when include: this surcharge is mandatory and included in the option's price
  # when exclude: this surcharge is not included in the option's price
  chargeType: ChargeType!
  
  # Indicates if the surcharge is mandatory or not. If mandatory, this surcharge will be applied to this option
  # if the chargeType is excluded the customer will have to pay it directly at the hotel
  mandatory: Boolean!
  
  # Indicates the surcharge price.
  price: Price!
  
  # Specifies the surcharge description.
  description: String
}

# Supplier transaction
type Transactions {
  # Transaction Request.
  request:        String!
  
  # Transaction Response.
  response:       String!
  
  # Time when the request has been processed.
  timeStamp:      DateTime!
}

# Application errors
type Error {
  # Error code
  code: String!

  # Error type
  type: String!

  # Error description
  description : String!
}

# Application warnings
type Warning {
  # Warning code
  code: String!

  # Warning type
  type: String!

  # Warning description
  description : String!
}

# The Country type represents Country values. A good example might be a Passenger Nationality.
# In queries or mutations, Country fields have to be specified in ISO 3166-1 alpha-2 format with enclosing double quotes "ES".
scalar Country

# The Currenty type represents Currency values. A good example might be a Rate Price Currency.
# In queries or mutations, Currency fields have to be specified in ISO 4217 format with enclosing double quotes "EUR".
scalar Currency

# The Date type represents Date values. A good example might be a Hotel CheckIn Date.
# In queries or mutations, DateTime fields have to be specified in ISO 8601 format with enclosing double quotes: "2017-10-22".
scalar Date

# The DateTime type represents DateTime values. A good example might be a transaction TimeSpan.
# In queries or mutations, DateTime fields have to be specified in ISO 8601 format with enclosing double quotes: "2017-10-22T13:57:31.123Z".
scalar DateTime

# The JSON type makes sure that it is actually valid JSON and returns the value as a parsed JSON object/array instead of a string.
# In queries or mutations, JSON fields have to be specified with enclosing double quotes. Special characters have to be escaped: "{\"int\": 1, \"string\": \"value\"}".
scalar JSON

# The Language type represents Language values. A good example might be a Hotel Description Language.
# In queries or mutations, Language fields have to be specified in ISO 3166-1 alpha-2 format with enclosing double quotes "es".
scalar Language

# The URI type represents a URI values. A good example mith be an Hotel Image URL.
# In queries or mutations, URI fields have to be specified in RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string format with enclosing double quotes: "http:\\www.travelgatex.com".
scalar URI

`},
)
